.\"t
.\" Automatically generated by Pandoc 2.5
.\"
.TH "" "" "" "" ""
.hy
.SH YAIDS
.PP
Yara\-Based IDS
.PP
Yara as an Intrusion Detection System / Yet Another Intrusion Detection
System
.PP
An Intrusion Detection System (IDS), utilizing Yara and multi\-threading
.PP
.PP
.PP
.SS Installation
.SS Prerequisites
.IP \[bu] 2
Development Toolkit (git, gcc, glibc, etc.)
.IP \[bu] 2
libpcap
.IP \[bu] 2
libyara (Version 4.X.X)
.IP \[bu] 2
POSIX Platform (Linux, etc.
\[en] YAIDS has been tested on Ubuntu 18.04 and 20.04)
.SS Ubuntu (Quick Install)
.IP "1." 3
Review and verify the
\f[C]quick\-install\-ubuntu.sh\f[R] (https://raw.githubusercontent.com/wrayjustin/yaids/main/quick-install-ubuntu.sh)
file.
.IP "2." 3
Run:
\f[C]curl \[dq]https://raw.githubusercontent.com/wrayjustin/yaids/main/quick\-install\-ubuntu.sh\[dq] | bash\f[R]
.SS Other Distributions (Basic Install)
.IP "1." 3
Install Development Tools (git, gcc, glibc, etc.)
.IP "2." 3
Install \f[C]libpcap\f[R] (including development headers)
.IP "3." 3
Install \f[C]libyara\f[R] (including development headers)
.IP "4." 3
Checkout the project:
\f[C]git clone https://github.com/wrayjustin/yaids.git\f[R]
.IP "5." 3
Run: \f[C]./build.sh\f[R]
.SS Manual/Development Installation
.IP "1." 3
Install Development Tools (git, gcc, glibc, etc.)
.IP "2." 3
Install \f[C]libpcap\f[R] (including development headers)
.IP "3." 3
Install \f[C]libyara\f[R] (including development headers)
.IP "4." 3
Checkout the project:
\f[C]git clone https://github.com/wrayjustin/yaids.git\f[R]
.IP "5." 3
Run: \f[C]./init.sh\f[R], \f[C]./configure\f[R], \f[C]make\f[R], and
\f[C]make install\f[R]
.SS Manual (Without AutoTools)
.IP "1." 3
Install Development Tools (git, gcc, glibc, etc.)
.IP "2." 3
Install \f[C]libpcap\f[R] (including development headers)
.IP "3." 3
Install \f[C]libyara\f[R] (including development headers)
.IP "4." 3
Compile (from the \f[C]src\f[R] directory):
\f[C]gcc <GCC OPTIONS> yaids.c yaidsconf.c yaidsio.c yaidspcap.c yaidsyara.c yaidsthread.c \-o yaids \-I. \-I.. \-I../include/ \-lpcap \-lyara \-lpthread \-lm <ADDITIONAL LIBRARIES>\f[R]
.SS Versioning
.PP
YAIDS uses a three value version number: X.Y.Z.
The version number is a modified form of \f[C]SemVer\f[R] (Semantic
Versioning).
.PP
Given the close dependency on \f[C]Yara\f[R], the first version value
maps to the compatible Major Yara release.
While \f[C]libpcap\f[R] is another major dependency of \f[C]yaids\f[R],
\f[C]libpcap\f[R] maintains binary compatibility across releases.
.PP
The YAIDS version fields: YARA_MAJOR.MAJOR.MINOR (For example, 4.0.0)
.IP \[bu] 2
YARA_MAJOR \- The compatible Yara (Major) version
.IP \[bu] 2
MAJOR \- Incremented on significant changes
.IP \[bu] 2
MINOR \- Incremented on minor changes or patches
.PP
Releases that increment the \f[I]YARA_MAJOR\f[R] field are highly likely
to be incompatible with differing versions of Yara.
Releases that increment the \f[I]MAJOR\f[R] field may be incompatible
with previous \f[C]yaids\f[R] releases.
Whereas \f[I]MINOR\f[R] releases should be forwards and backwards
compatible within the same \f[I]YARA_MAJOR.MAJOR\f[R] release family.
.PP
Note: At present, YAIDS is provided via rolling\-release; that is, there
is currently only a single line of releases.
However, that may potentially change on the release of the next
\f[I]major\f[R] Yara version.
.SS Usage
.PP
YAIDS can run on either an interface (live capture) or stored PCAP
files.
You can use any Yara supported rules.
.SS Examples
.PP
When running on a live interface, uee the following basic options:
\f[C]yaids \-i <interface> \-y <path/to/compiled/yara/rules>\f[R].
.PP
To process an exiisting PCAP file, use the following basic options:
\f[C]yaids \-r <path/to/pcap/file> \-y <path/to/compiled/yara/rules>\f[R].
.SS Options
.PP
You can obtain more information from the help message by running:
\f[C]yaids \-\-help\f[R] or \f[C]man yaids\f[R]
.IP
.nf
\f[C]
YAIDS \-\- 4.0.1
        Yara as an Intrusion Detection System / Yet Another Intrusion Detection System
        An Intrusion Detection System (IDS), utilizing Yara and multi\-threading
        COPYRIGHT (C) Justin M. Wray | Licensed: BSD 3\-Clause
\[u2500]\[u2500]\[u2500]\[u2500]\[u2500]\[u2500]\[u2500]\[u2500]\[u2500]\[u2500]\[u2500]\[u2500]\[u2500]\[u2500]\[u2500]\[u2500]\[u2500]\[u2500]\[u2500]\[u2500]\[u2500]\[u2500]\[u2500]\[u2500]\[u2500]\[u2500]\[u2500]\[u2500]\[u2500]\[u2500]\[u2500]\[u2500]\[u2500]\[u2500]\[u2500]\[u2500]\[u2500]\[u2500]\[u2500]\[u2500]\[u2500]\[u2500]\[u2500]\[u2500]\[u2500]\[u2500]\[u2500]\[u2500]\[u2500]\[u2500]\[u2500]\[u2500]\[u2500]\[u2500]\[u2500]\[u2500]\[u2500]\[u2500]\[u2500]\[u2500]\[u2500]\[u2500]\[u2500]\[u2500]\[u2500]\[u2500]\[u2500]\[u2500]\[u2500]\[u2500]\[u2500]\[u2500]\[u2500]\[u2500]\[u2500]\[u2500]\[u2500]\[u2500]\[u2500]\[u2500]\[u2500]\[u2500]\[u2500]\[u2500]\[u2500]\[u2500]\[u2500]\[u2500]\[u2500]\[u2500]\[u2500]\[u2500]\[u2500]\[u2500]\[u2500]\[u2500]\[u2500]\[u2500]\[u2500]\[u2500]\[u2500]\[u2500]\[u2500]\[u2500]\[u2500]\[u2500]\[u2500]\[u2500]\[u2500]\[u2500]\[u2500]\[u2500]\[u2500]\[u2500]\[u2500]\[u2500]\[u2500]\[u2500]\[u2500]\[u2500]\[u2500]
Usage:
        yaids
                \-i    <DEVICE>            Interface: The libpcap Interface Device name (\-i or \-r is required)
                \-r    <FILE>              Read: PCAP Input File (\-i or \-r is required)
                \-y    <FILE>              Rules: Yara Rules File, compiled (required)
                \-n    <NAME>              Prefix Name: Output files, prefix (optional, defaults to epoch)
                \-w    <PATH>              Output Path: Output path (optional, defaults to current working directory)
                \-f    <FILE>              BPF: BPF (PCAP Filter) File (optional, no traffic filtering)
                \-t    <INT>               Threads: Number of Yara Threads (optional, defaults to 2 + 4 x CPU cores)
                \-l    <INT>               Timelimit: Number of seconds to run, before exiting (optional, defaults to 0 \- run until finished or interrupted)
                \-s                        Silent Mode: Write output files, but don\[aq]t output alerts to STDOUT (optional, incompatible with Output Only Mode)
                \-o                        Output Only Mode: Output alerts to STDOUT only, does not write to files (optional, incompatible with Silent Mode)
                \-x                        Flush Mode: Prevents buffering of file output (optional)
                \-a                        Fast Alert Mode: Skip parsing packet headers for alerts (optional)
                \-d                        Debug Mode: Verbose output (optional)
                \-v                        Version: Show Version
                \-h                        Help: Show Help (this list)
\f[R]
.fi
.SS Output
.PP
By default, YAIDS processed output to both \f[C]stdout\f[R] and to log
files.
The default \f[C]stdout\f[R] provides alerts (rule matches), and two
logs are generated \- the alerts and PCAP of the triggered packets.
.PP
The alert output contains the following fields: * Timestamp
(YYYY\-MM\-DD HH:MM:SS) * Rule Name * Matching Rule Condition and
Trigger Location * Matching Packet Data * Header Length: Length Yara
Processed / PCAP Capture Length / Original Packet Length * Protocols:
Link\-Layer / Network / Transport * Layer\-2 Source > Layer\-2
Destination Addresses * Layer\-3 Source > Layer\-3 Destination Addresses
and Layer\-4 Ports (Address:Port)
.PP
An example alert:
.PP
\f[C]2020\-12\-20 01:01:01 \- Metasploit_Download [$s1:0x42:3] {GET /metasploitframework\-latest.msi} [171:171/171] (ETH/IP/TCP) 10:00:00:00:00:B3 > 10:00:00:00:00:F7 \- 198.51.100.12:41309 > 203.0.113.37:80\f[R]
.SS Rules
.PP
YAIDS supports any Yara\-compatible rule, including enabled and
adequately configured modules.
.PP
For convenience, YAIDS also provides a \[lq]drop\-in\[rq] replacement
for \f[C]yara\f[R] (the Yara Rules Compiler).
In addition to some feature enhancements, \f[C]yaidsc\f[R] sets
\[lq]external\[rq] variables for various packet offsets.
.PP
You can learn more about writing Yara rules from the Yara documentation:
Writing Yara
Rules (https://yara.readthedocs.io/en/stable/writingrules.html).
.SS yaidsc
.PP
\f[C]yaidsc\f[R] is a drop\-in replacement for \f[C]yarac\f[R] using an
identical syntax.
If needed, you can also pass additional options to \f[C]yarac\f[R].
Note that \f[C]yaidsc\f[R] is not a binary replacement for
\f[C]yarac\f[R]; it is a wrapper script.
The two major feature improvments are: * Multi\-File Support, including
Directories (which will compile all \f[C]*.yar\f[R] files in the
directories provided) * External Variables for Packet Fields
.IP
.nf
\f[C]
Usage:
        yaidsc <INPUT [NAMESPACE]FILES|DIRECTORIES...> <OUTPUT FILE> 

 * If the input is a directory, all \[aq].yar\[aq] files will be compiled.
 * You can compile multiple files or directories, one ruleset.
 * Namespaces can be provided, but only for individual files (not directories).
\f[R]
.fi
.SS Packet Headers and Offsets
.PP
To provide simple network\-related rule creation, without the need to
perform complex header parsing and calculations, \f[C]yaids\f[R]
includes a padded string\-based header before the PCAP data.
This additional data is only included during the \f[C]yara\f[R] scanning
(not in the PCAP output, etc.).
However, this does mean that the Packet Offsets are modified,
specifically by \f[C]255\f[R] bytes.
As a result, the raw packet data (including the unprocessed header)
begins at offset \f[C]256\f[R].
.SS Offsets
.PP
The processed (string\-based) header uses the following format:
.PP
.TS
tab(@);
lw(50.8n) lw(11.5n) lw(7.7n).
T{
Value
T}@T{
Offset Location
T}@T{
Field Size
T}
_
T{
Payload Offset
T}@T{
0
T}@T{
1 (Byte)
T}
T{
Original Packet (Length; This is regardless of the Capture Length)
T}@T{
1
T}@T{
5 (Str)
T}
T{
Frame Protocol
T}@T{
6
T}@T{
14 (Str)
T}
T{
Network Protocol
T}@T{
20
T}@T{
14 (Str)
T}
T{
Transport Protocol
T}@T{
34
T}@T{
14 (Str)
T}
T{
Frane Source Address
T}@T{
48
T}@T{
17 (Str)
T}
T{
Frame Destination Address
T}@T{
65
T}@T{
17 (Str)
T}
T{
Network Source Address
T}@T{
82
T}@T{
46 (Str)
T}
T{
Transport Source (Port)
T}@T{
128
T}@T{
5 (Str)
T}
T{
Network Destination Address:
T}@T{
133
T}@T{
46 (Str)
T}
T{
Transport Destination (Port)
T}@T{
179
T}@T{
5 (Str)
T}
.TE
.PP
Again, the packet data begins at byte \f[C]256\f[R].
.SS Offset Examples
.PP
One of the most powerful values of the processed header is the
\f[C]Payload Offset\f[R].
This offset value can be used in a \f[C]yara\f[R] \f[C]condition\f[R],
to match payload\-specific data.
Keep in mind, you need to jump an additional \f[C]255\f[R] bytes to the
begining of he packet data, in additon to payload offset.
For example:
.IP
.nf
\f[C]
rule example_01 {
    meta:
        author = \[dq]YAIDS.io\[dq]
        description = \[dq]YAIDS Example (HTTP GET Requests)\[dq]
        more_info = \[dq]https://yaids.io\[dq]
    strings:
        $string1 = \[dq]GET\[dq]
    condition:
        $string1 at (int8(0) + 255)
}
\f[R]
.fi
.PP
The remaining header offsets provide the ability to perform conditional
matching (filtering) on the listed packet attributes (addresses, ports,
etc.).
For example:
.IP
.nf
\f[C]
rule example_02 {
    meta:
        author = \[dq]YAIDS.io\[dq]
        description = \[dq]YAIDS Example (HTTP GET Requests)\[dq]
        more_info = \[dq]https://yaids.io\[dq]
    strings:
        $string1 = \[dq]GET\[dq]
        $frameProtocol = \[dq]ETH\[dq]
        $netProtocol = \[dq]IP\[dq]
        $transportProtocol = \[dq]TCP\[dq]
        $frameSource = \[dq]00:16:47:9D:F2:C2\[dq]
        $frameDest = \[dq]00:0C:29:89:D0:73\[dq]
        $networkSource = \[dq]192.168.21.101\[dq]
        $transportSource = \[dq]80\[dq]
        $networkDest = \[dq]192.168.202.90\[dq]
        $transportDest = \[dq]33783\[dq]
    condition:
        $frameProtocol at 6 and
        $netProtocol at 20 and
        $transportProtocol at 34 and
        $frameSource at 48 and
        $frameDest at 65 and
        $networkSource at 82 and
        $transportSource at 128 and
        $networkDest at 133 and
        $transportDest at 179 and
        $string1 at (int8(0) + 255)
}
\f[R]
.fi
.SS Yara External Variables
.PP
To simplify using the packet header values, \f[C]yaidsc\f[R] (the rule
compliler) will automatically provide \f[C]external variables\f[R].
When using \f[C]yaidsc\f[R] to compile your rules, there\[cq]s no need
to memorize the offset locations.
.PP
External Variables:
.PP
.TS
tab(@);
lw(55.7n) lw(14.3n).
T{
Value
T}@T{
Variable
T}
_
T{
Original Packet (Length; This is regardless of the Capture Length)
T}@T{
headerStart
T}
T{
Frame Protocol
T}@T{
frameProtocol
T}
T{
Network Protocol
T}@T{
netProtocol
T}
T{
Transport Protocol
T}@T{
transportProtocol
T}
T{
Frane Source Address
T}@T{
frameSource
T}
T{
Frame Destination Address
T}@T{
frameDest
T}
T{
Network Source Adderess
T}@T{
networkSource
T}
T{
Transport Source (Port)
T}@T{
transportSource
T}
T{
Network Destination Address:
T}@T{
networkDest
T}
T{
Transport Destination (Port)
T}@T{
transportDest
T}
.TE
.PP
Compare the previous two example to this example using the external
variables:
.IP
.nf
\f[C]
rule example_03 {
    meta:
        author = \[dq]YAIDS.io\[dq]
        description = \[dq]YAIDS Example (HTTP GET Requests)\[dq]
        more_info = \[dq]https://yaids.io\[dq]
    strings:
        $string1 = \[dq]GET\[dq]
        $frameProtocol = \[dq]ETH\[dq]
        $netProtocol = \[dq]IP\[dq]
        $transportProtocol = \[dq]TCP\[dq]
        $frameSource = \[dq]00:16:47:9D:F2:C2\[dq]
        $frameDest = \[dq]00:0C:29:89:D0:73\[dq]
        $networkSource = \[dq]192.168.21.101\[dq]
        $transportSource = \[dq]80\[dq]
        $networkDest = \[dq]192.168.202.90\[dq]
        $transportDest = \[dq]33783\[dq]
    condition:
        $frameProtocol at frameProtocol and
        $netProtocol at netProtocol and
        $transportProtocol at transportProtocol and
        $frameSource at frameSource and
        $frameDest at frameDest and
        $networkSource at networkSource and
        $transportSource at transportSource and
        $networkDest at networkDest and
        $transportDest at transportDest and
        $string1 at (int8(0) + 255)
}
\f[R]
.fi
.SS Supported Protocols
.PP
YAIDS supports all libpcap\-compatible data (network or otherwise).
.PP
However, the header parsing does have some limitations.
Only the following protocols will be parsed.
.SS Supported Layer\-2 / Frame Protocols
.PP
.TS
tab(@);
l l.
T{
Protocol Name
T}@T{
YAIDS Value
T}
_
T{
Ethernet
T}@T{
ETH
T}
.TE
.SS Supported Layer\-3 / Network Protocols
.PP
.TS
tab(@);
l l.
T{
Protocol Name
T}@T{
YAIDS Value
T}
_
T{
IPv4
T}@T{
IP
T}
T{
IPv6
T}@T{
IP6
T}
T{
8021AD
T}@T{
8021AD
T}
T{
8021Q
T}@T{
8021Q
T}
T{
8021QINQ
T}@T{
8021QINQ
T}
T{
AARP
T}@T{
AARP
T}
T{
ARP
T}@T{
ARP
T}
T{
ATALK
T}@T{
ATALK
T}
T{
DECDNS
T}@T{
DECDNS
T}
T{
DECDTS
T}@T{
DECDTS
T}
T{
DN
T}@T{
DN
T}
T{
IPX
T}@T{
IPX
T}
T{
LANBRIDGE
T}@T{
LANBRIDGE
T}
T{
LAT
T}@T{
LAT
T}
T{
LOOPBACK
T}@T{
LOOPBACK
T}
T{
MOPDL
T}@T{
MOPDL
T}
T{
MOPRC
T}@T{
MOPRC
T}
T{
MPLS
T}@T{
MPLS
T}
T{
MPLS_MULTI
T}@T{
MPLS_MULTI
T}
T{
NS
T}@T{
NS
T}
T{
PPPOED
T}@T{
PPPOED
T}
T{
PPPOES
T}@T{
PPPOES
T}
T{
PPP
T}@T{
PPP
T}
T{
PUP
T}@T{
PUP
T}
T{
REVARP
T}@T{
REVARP
T}
T{
SCA
T}@T{
SCA
T}
T{
SPRITE
T}@T{
SPRITE
T}
T{
TEB
T}@T{
TEB
T}
T{
TRAIL
T}@T{
TRAIL
T}
T{
VEXP
T}@T{
VEXP
T}
T{
VPROD
T}@T{
VPROD
T}
.TE
.SS Supported Layer\-4 / Transport Protocols
.PP
.TS
tab(@);
l l.
T{
Protocol Name
T}@T{
YAIDS Value
T}
_
T{
TCP
T}@T{
TCP
T}
T{
UDP
T}@T{
UDP
T}
T{
ICMP
T}@T{
ICMP
T}
.TE
.PP
Remember, you can write rules for \f[I]any\f[R] traffic type, but if the
protocols are not listed above, \f[C]yaids\f[R] will not automatically
parse the headers and therefore will not populate the
\f[C]External Variables\f[R]
.PP
In cases where the protocol is unsupported, the default value will be
\[lq]UNKN\[rq], which will be used in the alert output and the
\f[C]External Variables\f[R].
.SS Technical Details
.PP
The processing flow of YAIDS is straight\-forward; data comes in, is
processed, and then goes out: \f[I]INPUT\->PROCESSING\->OUTPUT\f[R].
.PP
The complexity comes from multi\-threading.
Although network streams (from a device or file) are serial, the
packets\[cq] processing can be computationally expensive and
long\-lived.
Put simply, packets traverse the network faster than an IDS can examine.
.PP
YAIDS resolves this disadvantage by parallelizing the processing of
packets.
Thus, the flow is more complex: * Input: \f[I]INPUT\->INPUT QUEUE\f[R] *
Processing: \f[I]IINPUT QUEUE\->PROCESSING\->OUTPUT QUEUE\f[R] * Output:
\f[I]OUTPUT QUEUE\->OUTPUT\f[R]
.PP
To obtain a better understanding of this processing flow, review the
flowchart.
.SS Priority
.PP
For live captures, the \f[I]INPUT\f[R] is prioritized to prevent
missing/dropping packets.
For offline processing (reading of a PCAP file), the processing is
prioritized to optimize the speed.
.PP
Priority is achieved through the utilization of a triple
\f[C]mutex\f[R]: * Read/Low Priority * Next * Write/High Priority
.SS Data Queues
.PP
Data queues are created via a series of \f[C]structs\f[R] with a pointer
to the subsequent \f[C]struct\f[R].
This is combined with a separate \[lq]queue\[rq] \f[C]struct\f[R]
containing pointers to the \f[I]first\f[R] and \f[I]last\f[R] data
\f[C]structs\f[R].
.IP
.nf
\f[C]
+\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-+     +\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-+     +\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-+     +\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-+
|                 |     |                 |     |                 |     |                 |
|  DATA           |     |  DATA           |     |  DATA           |     |  DATA           |
|                 |     |                 |     |                 |     |                 |
|          Next*\-\-\-\-\-\-\-\->          Next*\-\-\-\-\-\-\-\->          Next*\-\-\-\-\-\-\-\->          Next*\-\-\-\-\-\-\-\->NULL
+\-\-\-\-\-\-\[ha]\-\-\-\-\-\-\-\-\-\-+     +\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-+     +\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-+     +\-\-\-\-\-\-\[ha]\-\-\-\-\-\-\-\-\-\-+
       |                                                                       |
       |                                                                       |
+\-\-\-\-\-\-|\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-|\-\-\-\-\-\-\-\-\-\-+
| First*                                                                   Last*          |
|                                                                                         |
|                                          QUEUE                                          |
|                                                                                         |
+\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-+
\f[R]
.fi
.SS Flowchart
.IP
.nf
\f[C]
                                    *\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-*
                                    |                 |
                                    |     Packets     |
                                    |                 |
                                    |                 |
                                    *\-\-\-\-\-\-\-\-v\-\-\-\-\-\-\-\-*
                                             |
                                             |
                                             |
                                             |
                                    #\-\-\-\-\-\-\-\-v\-\-\-\-\-\-\-\-#
                                    |                 |
                                    |     Input       |
                                    |     Thread      |
                                    |                 |
                                    #\-\-\-\-\-\-\-\-v\-\-\-\-\-\-\-\-#
                                             |
                                             |
                                             |
                                             |
                                    +\-\-\-\-\-\-\-\-V\-\-\-\-\-\-\-\-+
                                    |                 |
                                    |     Input       |
                                    |     Queue       |
                                    |                 |
                                    +\-\-v\-\-v\-\-\-\-\-v\-\-v\-\-+
         +\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-+  |     |  +\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-
         |                                |     |                                |
         |                       +\-\-\-\-\-\-\-\-+     +\-\-\-\-\-\-\-\-+                       }
         |                       |                       |                       |
#\-\-\-\-\-\-\-\-V\-\-\-\-\-\-\-\-#     #\-\-\-\-\-\-\-\-V\-\-\-\-\-\-\-\-#     #\-\-\-\-\-\-\-\-V\-\-\-\-\-\-\-\-#     #\-\-\-\-\-\-\-\-V\-\-\-\-\-\-\-\-#
|                 |     |                 |     |                 |     |                 |
|    Yara         |     |    Yara         |     |    Yara         |     |    Yara         |
|    Thread 1     |     |    Thread 2     |     |    Thread 3     |     |    Thread ...   |
|                 |     |                 |     |                 |     |                 |
#\-\-\-\-\-\-\-\-v\-\-\-\-\-\-\-\-#     #\-\-\-\-\-\-\-\-v\-\-\-\-\-\-\-\-#     #\-\-\-\-\-\-\-\-v\-\-\-\-\-\-\-\-#     #\-\-\-\-\-\-\-\-v\-\-\-\-\-\-\-\-#
         |                       |                       |                       |
         |                       +\-\-\-\-\-\-\-\-+     +\-\-\-\-\-\-\-\-+                       |
         |                                |     |                                |
         +\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-+  |     |  +\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-|
                                    +\-\-V\-\-V\-\-\-\-\-V\-\-V\-\-+
                                    |                 |
                                    |     Output      |
                                    |     Queue       |
                                    |                 |
                                    +\-\-\-\-\-\-\-\-v\-\-\-\-\-\-\-\-+
                                             |
                                             |
                                             |
                                             |
                                    #\-\-\-\-\-\-\-\-V\-\-\-\-\-\-\-\-#
                                    |                 |
                                    |     Output      |
                                    |     Thread      |
                                    |                 |
                                    #\-\-\-v\-\-\-\-\-\-\-\-\-v\-\-\-#
                                        |         |
                                        |         |
                                 +\-\-\-\-\-\-+         +\-\-\-\-\-\-+
                                 |                       |
                        *\-\-\-\-\-\-\-\-V\-\-\-\-\-\-\-\-*     *\-\-\-\-\-\-\-\-V\-\-\-\-\-\-\-\-*
                        |                 |     |                 |
                        |      PCAP       |     |      Alert      |
                        |      File       |     |      File       |
                        |                 |     |                 |
                        *\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-*     *\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-*
\f[R]
.fi
.SS Code Testing
.PP
YAIDS is tested using both automated and manual processes.
The testing conducted covers functional testing, security testing, and
code quality analysis.
.PP
Some of the tools utilized for testing include: *
CodeQL (https://securitylab.github.com/tools/codeql) *
valgrind (https://valgrind.org/) * AFL/american fuzzy
lop (https://lcamtuf.coredump.cx/afl/) *
mutiny (https://github.com/Cisco-Talos/mutiny-fuzzer) *
ShellCheck (https://www.shellcheck.net/) * gcc (\-Wall and
\-Werror) (https://gcc.gnu.org/onlinedocs/gcc/Warning-Options.html)
.PP
In addition to the third\-party tools listed above, \f[C]yaids\f[R]
inclues a \f[I]test
suite\f[R] (https://github.com/wrayjustin/yaids/tree/main/tests).
.SS Test Suite
.PP
The test suite includes PCAP files and Yara Rules, and verifies that
multiple modes of \f[C]yaids\f[R] return the correct alerts and output.
.PP
The following modes are tested: * Output Mode * Silent Mode * Default
Mode / Re\-Processing of the Default Mode output
.PP
The following test cases are included in the test suite:
.PP
.TS
tab(@);
l l l.
T{
Test Name
T}@T{
Test Count
T}@T{
Description
T}
_
T{
test_A
T}@T{
6
T}@T{
HTTP Traffic/Rules
T}
T{
test_B
T}@T{
3
T}@T{
FTP Traffic/Rules
T}
T{
test_C
T}@T{
1
T}@T{
UDP Traffic/Rules
T}
T{
test_D
T}@T{
9
T}@T{
Traffic Attributes (Source, Destination, etc.)
T}
T{
test_E
T}@T{
1
T}@T{
Combined Ruleset
T}
T{
test_F
T}@T{
3
T}@T{
BPF Test
T}
.TE
.PP
All tests are run three times to ensure consistent results.
Additionally, the tests are run using both standard PCAP and PCAPNG
files.
.PP
NOTE: The PCAP files included for testing purposes are sources from
NETRESEC (https://www.netresec.com/?page=MACCDC).
.SS Automated Testing Workflows
.PP
There are three sets of tests conducted automatically on the
yaids/main (https://github.com/wrayjustin/yaids) branch.
The statuses of these tests are displayed at the top of the
documentation.
Furthermore, you can view the historical results for these workflows via
.IP \[bu] 2
Build
Testing (https://github.com/wrayjustin/yaids/blob/main/.github/workflows/build.yml)
.IP \[bu] 2
Test
Suite (https://github.com/wrayjustin/yaids/blob/main/.github/workflows/tests.yml)
.IP \[bu] 2
Code
Quality/CodeQL (https://github.com/wrayjustin/yaids/blob/main/.github/workflows/codeql-analysis.yml)
.SS License
.IP
.nf
\f[C]
COPYRIGHT (C) 2020 Justin M. Wray \- wray.justin\[at]gmail.com / https://www.justinwray.com
ALL RIGHTS RESERVED

Redistribution and use in source and binary forms, with or without modification,
are permitted provided that the following conditions are met:

1. Redistributions of source code must retain the above copyright notice, this
list of conditions and the following disclaimer.

2. Redistributions in binary form must reproduce the above copyright notice,
this list of conditions and the following disclaimer in the documentation and/or
other materials provided with the distribution.

3. Neither the name of the copyright holder nor the names of its contributors
may be used to endorse or promote products derived from this software without
specific prior written permission.

THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \[dq]AS IS\[dq] AND
ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR
ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
\f[R]
.fi
