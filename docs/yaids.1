.\" Automatically generated by Pandoc 2.5
.\"
.TH "YAIDS" "" "" "" ""
.hy
.PP
 # YAIDS
.PP
Yara\-Based IDS
.PP
Yara as an Intrusion Detection System / Yet Another Intrusion Detection
System
.PP
An Intrusion Detection System (IDS), utilizing Yara and multi\-threading
.PP
[IMAGE: Build (https://github.com/wrayjustin/yaids/workflows/Build/badge.svg)] (https://github.com/wrayjustin/yaids/actions?query=workflow%3ABuild)
[IMAGE: Code
Analysis (https://github.com/wrayjustin/yaids/workflows/Code%20Analysis/badge.svg)] (https://github.com/wrayjustin/yaids/actions?query=workflow%3A%22Code+Analysis%22)
.SS Documentation
.PP
.PP
 # Installation
.PP
.PP
 # Usage
.PP
.PP
 # Technical Design
.PP
.PP
 # Code
.IP
.nf
\f[C]
The full source code can be viewed in the [yaids/main](https://github.com/wrayjustin/yaids) repository
\f[R]
.fi
.PP
.PP
 # Headers
.IP
.nf
\f[C]
The full source code can be viewed in the [yaids/main](https://github.com/wrayjustin/yaids) repository
\f[R]
.fi
.PP
.PP
 # Data Definitions
.IP
.nf
\f[C]
The full source code can be viewed in the [yaids/main](https://github.com/wrayjustin/yaids) repository
\f[R]
.fi
.PP
.PP
 # Source
.IP
.nf
\f[C]
The full source code can be viewed in the [yaids/main](https://github.com/wrayjustin/yaids) repository
\f[R]
.fi
.PP
.PP
 # Prerequisites
.IP \[bu] 2
Development Toolkit (git, gcc, glibc, etc.)
.IP \[bu] 2
libpcap
.IP \[bu] 2
libyara (Version 4.X.X)
.IP \[bu] 2
POSIX Platform (Linux, etc.
\[en] YAIDS has been tested on Ubuntu 18.04 and 20.04)
.PP
 # Ubuntu (Quick Install)
.IP
.nf
\f[C]
This is the recommended installation method if you are running Ubuntu
\f[R]
.fi
.IP "1." 3
Review and verify the
\f[C]quick\-install\-ubuntu.sh\f[R] (https://raw.githubusercontent.com/wrayjustin/yaids/main/quick-install-ubuntu.sh)
file.
.IP "2." 3
Run:
\f[C]curl \[dq]https://raw.githubusercontent.com/wrayjustin/yaids/main/quick\-install\-ubuntu.sh\[dq] | bash\f[R]
.PP
 # Other Distributions (Basic Install)
.IP
.nf
\f[C]
Most modern distributions should include the required dependencies, monitor the \[ga]./configure\[ga] output for any missing packages
\f[R]
.fi
.IP "1." 3
Install Development Tools (git, gcc, glibc, etc.)
.IP "2." 3
Install \f[C]libpcap\f[R] (including development headers)
.IP "3." 3
Install \f[C]libyara\f[R] (including development headers)
.IP "4." 3
Checkout the project:
\f[C]git clone https://github.com/wrayjustin/yaids.git\f[R]
.IP "5." 3
Run: \f[C]./build.sh\f[R]
.PP
 # Manual/Development Installation
.IP
.nf
\f[C]
Most modern distributions should include the required dependencies, monitor the \[ga]./configure\[ga] output for any missing packages
\f[R]
.fi
.IP "1." 3
Install Development Tools (git, gcc, glibc, etc.)
.IP "2." 3
Install \f[C]libpcap\f[R] (including development headers)
.IP "3." 3
Install \f[C]libyara\f[R] (including development headers)
.IP "4." 3
Checkout the project:
\f[C]git clone https://github.com/wrayjustin/yaids.git\f[R]
.IP "5." 3
Run: \f[C]./init.sh\f[R], \f[C]./configure\f[R], \f[C]make\f[R], and
\f[C]make install\f[R]
.PP
 # Manual (Without AutoTools)
.IP
.nf
\f[C]
Most modern distributions should include the required dependencies, monitor the \[ga]./configure\[ga] output for any missing packages; Lack of optimization may impact the performace of \[ga]YAIDS\[ga]
\f[R]
.fi
.IP "1." 3
Install Development Tools (git, gcc, glibc, etc.)
.IP "2." 3
Install \f[C]libpcap\f[R] (including development headers)
.IP "3." 3
Install \f[C]libyara\f[R] (including development headers)
.IP "4." 3
Compile (from the \f[C]src\f[R] directory):
\f[C]gcc <GCC OPTIONS> yaids.c yaidsconf.c yaidsio.c yaidspcap.c yaidsyara.c yaidsthread.c \-o yaids \-I. \-I.. \-I../include/ \-lpcap \-lyara \-lpthread \-lm <ADDITIONAL LIBRARIES>\f[R]
.PP
 # Command Line Options
.PP
You can obtain more information from the help message by running:
\f[C]yaids \-\-help\f[R]
.IP
.nf
\f[C]
YAIDS \-\- 0.0.1
        Yara as an Intrusion Detection System / Yet Another Intrusion Detection System
        An Intrusion Detection System (IDS), utilizing Yara and multi\-threading
        COPYRIGHT (C) Justin M. Wray | Licensed: BSD 3\-Clause
\[u2500]\[u2500]\[u2500]\[u2500]\[u2500]\[u2500]\[u2500]\[u2500]\[u2500]\[u2500]\[u2500]\[u2500]\[u2500]\[u2500]\[u2500]\[u2500]\[u2500]\[u2500]\[u2500]\[u2500]\[u2500]\[u2500]\[u2500]\[u2500]\[u2500]\[u2500]\[u2500]\[u2500]\[u2500]\[u2500]\[u2500]\[u2500]\[u2500]\[u2500]\[u2500]\[u2500]\[u2500]\[u2500]\[u2500]\[u2500]\[u2500]\[u2500]\[u2500]\[u2500]\[u2500]\[u2500]\[u2500]\[u2500]\[u2500]\[u2500]\[u2500]\[u2500]\[u2500]\[u2500]\[u2500]\[u2500]\[u2500]\[u2500]\[u2500]\[u2500]\[u2500]\[u2500]\[u2500]\[u2500]\[u2500]\[u2500]\[u2500]\[u2500]\[u2500]\[u2500]\[u2500]\[u2500]\[u2500]\[u2500]\[u2500]\[u2500]\[u2500]\[u2500]\[u2500]\[u2500]\[u2500]\[u2500]\[u2500]\[u2500]\[u2500]\[u2500]\[u2500]\[u2500]\[u2500]\[u2500]\[u2500]\[u2500]\[u2500]\[u2500]\[u2500]\[u2500]\[u2500]\[u2500]\[u2500]\[u2500]\[u2500]\[u2500]\[u2500]\[u2500]\[u2500]\[u2500]\[u2500]\[u2500]\[u2500]\[u2500]\[u2500]\[u2500]\[u2500]\[u2500]\[u2500]\[u2500]\[u2500]\[u2500]\[u2500]\[u2500]\[u2500]
Usage:
        yaids
                \-i    <DEVICE>            Interface: The libpcap Interface Device name (\-i or \-r is required)
                \-r    <FILE>              Read: PCAP Input File (\-i or \-r is required)
                \-y    <FILE>              Rules: Yara Rules File, compiled (required)
                \-n    <NAME>              Prefix Name: Output files, prefix (optional, defaults to epoch)
                \-w    <PATH>              Output Path: Output path (optional, defaults to current working directory)
                \-t    <INT>               Threads: Number of Yara Threads (optional, defaults to 2 + 4 x CPU cores)
                \-l    <INT>               Timelimit: Number of seconds to run, before exiting (optional, defaults to 0 \- run until finished or interrupted)
                \-s                        Silent Mode: Write output files, but don\[aq]t output alerts to STDOUT (optional, incompatible with Output Only Mode)
                \-o                        Output Only Mode: Output alerts to STDOUT only, does not write to files (optional, incompatible with Silent Mode)
                \-x                        Flush Mode: Prevents buffering of file output (optional)
                \-a                        Fast Alert Mode: Skip parsing packet headers for alerts (optional)
                \-d                        Debug Mode: Verbose output (optional)
                \-v                        Version: Show Version
                \-h                        Help: Show Help (this list)
\f[R]
.fi
.PP
 # Examples
.PP
When running on a live interface, uee the following basic options:
\f[C]yaids \-i <interface> \-y <path/to/compiled/yara/rules>\f[R].
.PP
To process an exiisting PCAP file, use the following basic options:
\f[C]yaids \-r <path/to/pcap/file> \-y <path/to/compiled/yara/rules>\f[R].
.PP
 # Output
.PP
By default, YAIDS processed output to both \f[C]stdout\f[R] and to log
files.
The default \f[C]stdout\f[R] provides alerts (rule matches), and two
logs are generated \- the alerts and PCAP of the triggered packets.
.PP
The alert output contains the following fields: * Timestamp
(YYYY\-MM\-DD HH:MM:SS) * Rule Name * Matching Rule Condition and
Trigger Location * Matching Packet Data * Header Length: Length Yara
Processed / PCAP Capture Length / Original Packet Length * Protocols:
Link\-Layer / Network / Transport * Layer\-2 Source > Layer\-2
Destination Addresses * Layer\-3 Source > Layer\-3 Destination Addresses
and Layer\-4 Ports (Address:Port)
.PP
An example alert:
.PP
\f[C]2020\-12\-20 01:01:01 \- Metasploit_Download [$s1:0x42:3] {GET /metasploitframework\-latest.msi} [171:171/171] (ETH/IP/TCP) 10:00:00:00:00:B3 > 10:00:00:00:00:F7 \- 198.51.100.12:41309 > 203.0.113.37:80\f[R]
.PP
 # Dataflow
.PP
The processing flow of YAIDS is straight\-forward; data comes in, is
processed, and then goes out: \f[I]INPUT\->PROCESSING\->OUTPUT\f[R].
.PP
The complexity comes from multi\-threading.
Although network streams (from a device or file) are serial, the
packets\[cq] processing can be computationally expensive and
long\-lived.
Put simply, packets traverse the network faster than an IDS can examine.
.PP
YAIDS resolves this disadvantage by parallelizing the processing of
packets.
Thus, the flow is more complex: * Input: \f[I]INPUT\->INPUT QUEUE\f[R] *
Processing: \f[I]IINPUT QUEUE\->PROCESSING\->OUTPUT QUEUE\f[R] * Output:
\f[I]OUTPUT QUEUE\->OUTPUT\f[R]
.PP
To obtain a better understanding of this processing flow, review the
flowchart below.
.PP
 # Thread Priority
.PP
For live captures, the \f[I]INPUT\f[R] is prioritized to prevent
missing/dropping packets.
For offline processing (reading of a PCAP file), the processing is
prioritized to optimize the speed.
.PP
Priority is achieved through the utilization of a triple
\f[C]mutex\f[R]: * Read/Low Priority * Next * Write/High Priority
.PP
 # Data Queues
.PP
Data queues are created via a series of \f[C]structs\f[R] with a pointer
to the subsequent \f[C]struct\f[R].
This is combined with a separate \[lq]queue\[rq] \f[C]struct\f[R]
containing pointers to the \f[I]first\f[R] and \f[I]last\f[R] data
\f[C]structs\f[R].
.IP
.nf
\f[C]
+\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-+     +\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-+     +\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-+     +\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-+
|                 |     |                 |     |                 |     |                 |
|  DATA           |     |  DATA           |     |  DATA           |     |  DATA           |
|                 |     |                 |     |                 |     |                 |
|          Next*\-\-\-\-\-\-\-\->          Next*\-\-\-\-\-\-\-\->          Next*\-\-\-\-\-\-\-\->          Next*\-\-\-\-\-\-\-\->NULL
+\-\-\-\-\-\-\[ha]\-\-\-\-\-\-\-\-\-\-+     +\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-+     +\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-+     +\-\-\-\-\-\-\[ha]\-\-\-\-\-\-\-\-\-\-+
       |                                                                       |
       |                                                                       |
+\-\-\-\-\-\-|\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-|\-\-\-\-\-\-\-\-\-\-+
| First*                                                                   Last*          |
|                                                                                         |
|                                          QUEUE                                          |
|                                                                                         |
+\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-+
\f[R]
.fi
.PP
 # Flowchart
.IP
.nf
\f[C]
                                    *\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-*
                                    |                 |
                                    |     Packets     |
                                    |                 |
                                    |                 |
                                    *\-\-\-\-\-\-\-\-v\-\-\-\-\-\-\-\-*
                                             |
                                             |
                                             |
                                             |
                                    #\-\-\-\-\-\-\-\-v\-\-\-\-\-\-\-\-#
                                    |                 |
                                    |     Input       |
                                    |     Thread      |
                                    |                 |
                                    #\-\-\-\-\-\-\-\-v\-\-\-\-\-\-\-\-#
                                             |
                                             |
                                             |
                                             |
                                    +\-\-\-\-\-\-\-\-V\-\-\-\-\-\-\-\-+
                                    |                 |
                                    |     Input       |
                                    |     Queue       |
                                    |                 |
                                    +\-\-v\-\-v\-\-\-\-\-v\-\-v\-\-+
         +\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-+  |     |  +\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-
         |                                |     |                                |
         |                       +\-\-\-\-\-\-\-\-+     +\-\-\-\-\-\-\-\-+                       }
         |                       |                       |                       |
#\-\-\-\-\-\-\-\-V\-\-\-\-\-\-\-\-#     #\-\-\-\-\-\-\-\-V\-\-\-\-\-\-\-\-#     #\-\-\-\-\-\-\-\-V\-\-\-\-\-\-\-\-#     #\-\-\-\-\-\-\-\-V\-\-\-\-\-\-\-\-#
|                 |     |                 |     |                 |     |                 |
|    Yara         |     |    Yara         |     |    Yara         |     |    Yara         |
|    Thread 1     |     |    Thread 2     |     |    Thread 3     |     |    Thread ...   |
|                 |     |                 |     |                 |     |                 |
#\-\-\-\-\-\-\-\-v\-\-\-\-\-\-\-\-#     #\-\-\-\-\-\-\-\-v\-\-\-\-\-\-\-\-#     #\-\-\-\-\-\-\-\-v\-\-\-\-\-\-\-\-#     #\-\-\-\-\-\-\-\-v\-\-\-\-\-\-\-\-#
         |                       |                       |                       |
         |                       +\-\-\-\-\-\-\-\-+     +\-\-\-\-\-\-\-\-+                       |
         |                                |     |                                |
         +\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-+  |     |  +\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-|
                                    +\-\-V\-\-V\-\-\-\-\-V\-\-V\-\-+
                                    |                 |
                                    |     Output      |
                                    |     Queue       |
                                    |                 |
                                    +\-\-\-\-\-\-\-\-v\-\-\-\-\-\-\-\-+
                                             |
                                             |
                                             |
                                             |
                                    #\-\-\-\-\-\-\-\-V\-\-\-\-\-\-\-\-#
                                    |                 |
                                    |     Output      |
                                    |     Thread      |
                                    |                 |
                                    #\-\-\-v\-\-\-\-\-\-\-\-\-v\-\-\-#
                                        |         |
                                        |         |
                                 +\-\-\-\-\-\-+         +\-\-\-\-\-\-+
                                 |                       |
                        *\-\-\-\-\-\-\-\-V\-\-\-\-\-\-\-\-*     *\-\-\-\-\-\-\-\-V\-\-\-\-\-\-\-\-*
                        |                 |     |                 |
                        |      PCAP       |     |      Alert      |
                        |      File       |     |      File       |
                        |                 |     |                 |
                        *\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-*     *\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-*
\f[R]
.fi
.PP
 # ChangeLog
.SS Added Security Policy \- Thu Dec 24 01:27:52 2020 \-0500
.PP
13786f5 (https://github.com/wrayjustin/yaids/commit/13786f5e3d2d3f8ab3fb915bfc068cf049e2bc14)
by wrayjustin (https://github.com/wrayjustin)
.SS Removed Default Issue Template \- Bug \- Thu Dec 24 00:41:53 2020 \-0500
.PP
ca640dc (https://github.com/wrayjustin/yaids/commit/ca640dc2149c6fff88789fabd1a3edd5c60d202b)
by wrayjustin (https://github.com/wrayjustin)
.SS Created Issue Templates \- Thu Dec 24 00:40:58 2020 \-0500
.PP
1068a67 (https://github.com/wrayjustin/yaids/commit/1068a677e3c3696e9fdc3def344146c3f1080b3e)
by wrayjustin (https://github.com/wrayjustin)
.SS Code Cleanup and Hardening \- Thu Dec 24 04:33:11 2020 +0000
.PP
6c49bb3 (https://github.com/wrayjustin/yaids/commit/6c49bb3960dd07828645995bc80a50e1f0f9b53c)
by wrayjustin (https://github.com/wrayjustin)
.SS Add Workflow Badges \- Wed Dec 23 08:40:08 2020 +0000
.PP
481e74b (https://github.com/wrayjustin/yaids/commit/481e74b0b0fb638757cf45024040551a2a83bff5)
by wrayjustin (https://github.com/wrayjustin)
.SS Updated Code Analysis Workflow Name \- Wed Dec 23 03:28:37 2020 \-0500
.PP
df18c03 (https://github.com/wrayjustin/yaids/commit/df18c032d50f709b5e3a86d86168db2b0dd4ad4f)
by wrayjustin (https://github.com/wrayjustin)
.SS Update Build Workflow Name \- Wed Dec 23 03:26:55 2020 \-0500
.PP
7332168 (https://github.com/wrayjustin/yaids/commit/7332168a7b2489002400a5365f109294d28062c2)
by wrayjustin (https://github.com/wrayjustin)
.SS Add Code Analysis \- Wed Dec 23 03:18:56 2020 \-0500
.PP
5047c52 (https://github.com/wrayjustin/yaids/commit/5047c52bdbd4272f832bdce9bbb3d8954ab3915a)
by wrayjustin (https://github.com/wrayjustin)
.SS Add Build Testing Workflow \- Wed Dec 23 03:03:17 2020 \-0500
.PP
765fb6f (https://github.com/wrayjustin/yaids/commit/765fb6fd5b3ea0db59ab49d4a3a1529ae3fecf96)
by wrayjustin (https://github.com/wrayjustin)
.SS Code Cleanup \- Wed Dec 23 07:51:21 2020 +0000
.PP
f20efa7 (https://github.com/wrayjustin/yaids/commit/f20efa75f33181fa6efdf745e66bfca2ffd55a9f)
by wrayjustin (https://github.com/wrayjustin)
.SS Added \f[C]quick\-install\-ubuntu.sh\f[R] Script \- Sun Dec 20 22:42:08 2020 +0000
.PP
e8de2b9 (https://github.com/wrayjustin/yaids/commit/e8de2b9355678b2f40b18e10964864e72697111a)
by wrayjustin (https://github.com/wrayjustin)
.SS Minor Correction to Initial Upload \- Sun Dec 20 22:35:20 2020 +0000
.PP
1978a31 (https://github.com/wrayjustin/yaids/commit/1978a3137657ab80cf310b0216a385d43b8a1920)
by wrayjustin (https://github.com/wrayjustin)
.SS Initial upload to GitHub \- Sun Dec 20 22:16:12 2020 +0000
.PP
e188c02 (https://github.com/wrayjustin/yaids/commit/e188c02f59b5249f00abba61e9ebc11990fb7012)
by wrayjustin (https://github.com/wrayjustin)
.SS Initial commit \- Sun Dec 20 00:36:53 2020 \-0500
.PP
dadd1de (https://github.com/wrayjustin/yaids/commit/dadd1de6ba69ef6ac9d4b5435d99e168953bd199)
by wrayjustin (https://github.com/wrayjustin)
.PP
 # License
.IP
.nf
\f[C]
COPYRIGHT (C) 2020 Justin M. Wray \- wray.justin\[at]gmail.com / https://www.justinwray.com
ALL RIGHTS RESERVED

Redistribution and use in source and binary forms, with or without modification,
are permitted provided that the following conditions are met:

1. Redistributions of source code must retain the above copyright notice, this
list of conditions and the following disclaimer.

2. Redistributions in binary form must reproduce the above copyright notice,
this list of conditions and the following disclaimer in the documentation and/or
other materials provided with the distribution.

3. Neither the name of the copyright holder nor the names of its contributors
may be used to endorse or promote products derived from this software without
specific prior written permission.

THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \[dq]AS IS\[dq] AND
ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR
ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
\f[R]
.fi
.SH structyaidsConfig__struct
.PP
YAIDS
.PP
yaidsConfig_struct Struct Reference
.PP
\f[C]#include <yaidstypes.h>\f[R]
.SS  Public Attributes
.PP
int\ 
.PP
status
.PP
\ 
.PP
int\ 
.PP
debug
.PP
\ 
.PP
int\ 
.PP
threads
.PP
\ 
.PP
int\ 
.PP
timelimit
.PP
\ 
.PP
int\ 
.PP
read_pcap_file
.PP
\ 
.PP
int\ 
.PP
silent_mode
.PP
\ 
.PP
int\ 
.PP
output_mode
.PP
\ 
.PP
int\ 
.PP
flush_mode
.PP
\ 
.PP
int\ 
.PP
fast_alert_mode
.PP
\ 
.PP
char *\ 
.PP
pcapDevice
.PP
\ 
.PP
char *\ 
.PP
yaraRulesFile
.PP
\ 
.PP
char *\ 
.PP
outputPrefix
.PP
\ 
.PP
char *\ 
.PP
outputPath
.PP
\ 
.PP
char *\ 
.PP
pcapInputFile
.PP
\ 
.PP
char *\ 
.PP
outputAlertFile
.PP
\ 
.PP
char *\ 
.PP
outputPcapFile
.PP
\ 
.SS Member Data Documentation
.PP
.SS \[u25C6]\ debug
int yaidsConfig_struct::debug
.PP
.SS \[u25C6]\ fast_alert_mode
int yaidsConfig_struct::fast_alert_mode
.PP
.SS \[u25C6]\ flush_mode
int yaidsConfig_struct::flush_mode
.PP
.SS \[u25C6]\ output_mode
int yaidsConfig_struct::output_mode
.PP
.SS \[u25C6]\ outputAlertFile
char* yaidsConfig_struct::outputAlertFile
.PP
.SS \[u25C6]\ outputPath
char* yaidsConfig_struct::outputPath
.PP
.SS \[u25C6]\ outputPcapFile
char* yaidsConfig_struct::outputPcapFile
.PP
.SS \[u25C6]\ outputPrefix
char* yaidsConfig_struct::outputPrefix
.PP
.SS \[u25C6]\ pcapDevice
char* yaidsConfig_struct::pcapDevice
.PP
.SS \[u25C6]\ pcapInputFile
char* yaidsConfig_struct::pcapInputFile
.PP
.SS \[u25C6]\ read_pcap_file
int yaidsConfig_struct::read_pcap_file
.PP
.SS \[u25C6]\ silent_mode
int yaidsConfig_struct::silent_mode
.PP
.SS \[u25C6]\ status
int yaidsConfig_struct::status
.PP
.SS \[u25C6]\ threads
int yaidsConfig_struct::threads
.PP
.SS \[u25C6]\ timelimit
int yaidsConfig_struct::timelimit
.PP
.SS \[u25C6]\ yaraRulesFile
char* yaidsConfig_struct::yaraRulesFile
.PP
   *   *   *   *   *
.PP
The documentation for this struct was generated from the following file:
.IP \[bu] 2
include/yaidstypes.h
.PP
   *   *   *   *   *
.PP
Source Code Documentation Generated By \f[C]doxygen\f[R] \ 
.SH structyaidsInputDataNode__struct
.PP
YAIDS
.PP
yaidsInputDataNode_struct Struct Reference
.PP
\f[C]#include <yaidstypes.h>\f[R]
.PP
Collaboration diagram for yaidsInputDataNode_struct:
.PP
[IMAGE: Collaboration
graph (/images/structyaidsInputDataNode__struct__coll__graph.png)]
.SS  Public Attributes
.PP
struct yaidsInputDataNode_struct *\ 
.PP
nextNode
.PP
\ 
.PP
yaidsPcapPacket_ptr\ 
.PP
data
.PP
\ 
.SS Member Data Documentation
.PP
.SS \[u25C6]\ data
yaidsPcapPacket_ptr yaidsInputDataNode_struct::data
.PP
.SS \[u25C6]\ nextNode
struct yaidsInputDataNode_struct* yaidsInputDataNode_struct::nextNode
.PP
   *   *   *   *   *
.PP
The documentation for this struct was generated from the following file:
.IP \[bu] 2
include/yaidstypes.h
.PP
   *   *   *   *   *
.PP
Source Code Documentation Generated By \f[C]doxygen\f[R] \ 
.SH structyaidsInputDataQueue__struct
.PP
YAIDS
.PP
yaidsInputDataQueue_struct Struct Reference
.PP
\f[C]#include <yaidstypes.h>\f[R]
.PP
Collaboration diagram for yaidsInputDataQueue_struct:
.PP
[IMAGE: Collaboration
graph (/images/structyaidsInputDataQueue__struct__coll__graph.png)]
.SS  Public Attributes
.PP
yaidsInputDataNode_ptr\ 
.PP
firstNode
.PP
\ 
.PP
yaidsInputDataNode_ptr\ 
.PP
lastNode
.PP
\ 
.SS Member Data Documentation
.PP
.SS \[u25C6]\ firstNode
yaidsInputDataNode_ptr yaidsInputDataQueue_struct::firstNode
.PP
.SS \[u25C6]\ lastNode
yaidsInputDataNode_ptr yaidsInputDataQueue_struct::lastNode
.PP
   *   *   *   *   *
.PP
The documentation for this struct was generated from the following file:
.IP \[bu] 2
include/yaidstypes.h
.PP
   *   *   *   *   *
.PP
Source Code Documentation Generated By \f[C]doxygen\f[R] \ 
.SH structyaidsInputThreadArgs__struct
.PP
YAIDS
.PP
yaidsInputThreadArgs_struct Struct Reference
.PP
\f[C]#include <yaidstypes.h>\f[R]
.PP
Collaboration diagram for yaidsInputThreadArgs_struct:
.PP
[IMAGE: Collaboration
graph (/images/structyaidsInputThreadArgs__struct__coll__graph.png)]
.SS  Public Attributes
.PP
yaidsInputDataQueue_ptr\ 
.PP
dataQueue
.PP
\ 
.PP
yaidsPcapHandle_ptr\ 
.PP
pcapHandle
.PP
\ 
.PP
yaidsConfig_ptr\ 
.PP
config
.PP
\ 
.PP
yaidsPacketCounts_ptr\ 
.PP
packetCounts
.PP
\ 
.PP
yaidsThreadStatuses_ptr\ 
.PP
threadStatuses
.PP
\ 
.SS Member Data Documentation
.PP
.SS \[u25C6]\ config
yaidsConfig_ptr yaidsInputThreadArgs_struct::config
.PP
.SS \[u25C6]\ dataQueue
yaidsInputDataQueue_ptr yaidsInputThreadArgs_struct::dataQueue
.PP
.SS \[u25C6]\ packetCounts
yaidsPacketCounts_ptr yaidsInputThreadArgs_struct::packetCounts
.PP
.SS \[u25C6]\ pcapHandle
yaidsPcapHandle_ptr yaidsInputThreadArgs_struct::pcapHandle
.PP
.SS \[u25C6]\ threadStatuses
yaidsThreadStatuses_ptr yaidsInputThreadArgs_struct::threadStatuses
.PP
   *   *   *   *   *
.PP
The documentation for this struct was generated from the following file:
.IP \[bu] 2
include/yaidstypes.h
.PP
   *   *   *   *   *
.PP
Source Code Documentation Generated By \f[C]doxygen\f[R] \ 
.SH structyaidsOutputDataNode__struct
.PP
YAIDS
.PP
yaidsOutputDataNode_struct Struct Reference
.PP
\f[C]#include <yaidstypes.h>\f[R]
.PP
Collaboration diagram for yaidsOutputDataNode_struct:
.PP
[IMAGE: Collaboration
graph (/images/structyaidsOutputDataNode__struct__coll__graph.png)]
.SS  Public Attributes
.PP
struct yaidsOutputDataNode_struct *\ 
.PP
nextNode
.PP
\ 
.PP
yaidsPcapPacket_ptr\ 
.PP
data
.PP
\ 
.PP
char *\ 
.PP
alert
.PP
\ 
.SS Member Data Documentation
.PP
.SS \[u25C6]\ alert
char* yaidsOutputDataNode_struct::alert
.PP
.SS \[u25C6]\ data
yaidsPcapPacket_ptr yaidsOutputDataNode_struct::data
.PP
.SS \[u25C6]\ nextNode
struct yaidsOutputDataNode_struct* yaidsOutputDataNode_struct::nextNode
.PP
   *   *   *   *   *
.PP
The documentation for this struct was generated from the following file:
.IP \[bu] 2
include/yaidstypes.h
.PP
   *   *   *   *   *
.PP
Source Code Documentation Generated By \f[C]doxygen\f[R] \ 
.SH structyaidsOutputDataQueue__struct
.PP
YAIDS
.PP
yaidsOutputDataQueue_struct Struct Reference
.PP
\f[C]#include <yaidstypes.h>\f[R]
.PP
Collaboration diagram for yaidsOutputDataQueue_struct:
.PP
[IMAGE: Collaboration
graph (/images/structyaidsOutputDataQueue__struct__coll__graph.png)]
.SS  Public Attributes
.PP
yaidsOutputDataNode_ptr\ 
.PP
firstNode
.PP
\ 
.PP
yaidsOutputDataNode_ptr\ 
.PP
lastNode
.PP
\ 
.SS Member Data Documentation
.PP
.SS \[u25C6]\ firstNode
yaidsOutputDataNode_ptr yaidsOutputDataQueue_struct::firstNode
.PP
.SS \[u25C6]\ lastNode
yaidsOutputDataNode_ptr yaidsOutputDataQueue_struct::lastNode
.PP
   *   *   *   *   *
.PP
The documentation for this struct was generated from the following file:
.IP \[bu] 2
include/yaidstypes.h
.PP
   *   *   *   *   *
.PP
Source Code Documentation Generated By \f[C]doxygen\f[R] \ 
.SH structyaidsOutputThreadArgs__struct
.PP
YAIDS
.PP
yaidsOutputThreadArgs_struct Struct Reference
.PP
\f[C]#include <yaidstypes.h>\f[R]
.PP
Collaboration diagram for yaidsOutputThreadArgs_struct:
.PP
[IMAGE: Collaboration
graph (/images/structyaidsOutputThreadArgs__struct__coll__graph.png)]
.SS  Public Attributes
.PP
yaidsOutputDataQueue_ptr\ 
.PP
dataQueue
.PP
\ 
.PP
yaidsPcapHandle_ptr\ 
.PP
pcapHandle
.PP
\ 
.PP
yaidsConfig_ptr\ 
.PP
config
.PP
\ 
.PP
yaidsPacketCounts_ptr\ 
.PP
packetCounts
.PP
\ 
.PP
yaidsThreadStatuses_ptr\ 
.PP
threadStatuses
.PP
\ 
.SS Member Data Documentation
.PP
.SS \[u25C6]\ config
yaidsConfig_ptr yaidsOutputThreadArgs_struct::config
.PP
.SS \[u25C6]\ dataQueue
yaidsOutputDataQueue_ptr yaidsOutputThreadArgs_struct::dataQueue
.PP
.SS \[u25C6]\ packetCounts
yaidsPacketCounts_ptr yaidsOutputThreadArgs_struct::packetCounts
.PP
.SS \[u25C6]\ pcapHandle
yaidsPcapHandle_ptr yaidsOutputThreadArgs_struct::pcapHandle
.PP
.SS \[u25C6]\ threadStatuses
yaidsThreadStatuses_ptr yaidsOutputThreadArgs_struct::threadStatuses
.PP
   *   *   *   *   *
.PP
The documentation for this struct was generated from the following file:
.IP \[bu] 2
include/yaidstypes.h
.PP
   *   *   *   *   *
.PP
Source Code Documentation Generated By \f[C]doxygen\f[R] \ 
.SH structyaidsPacketCounts__struct
.PP
YAIDS
.PP
yaidsPacketCounts_struct Struct Reference
.PP
\f[C]#include <yaidstypes.h>\f[R]
.SS  Public Attributes
.PP
int\ 
.PP
pcapPacketCount
.PP
\ 
.PP
int\ 
.PP
yaraPacketCount
.PP
\ 
.PP
int\ 
.PP
alertPacketCount
.PP
\ 
.PP
int\ 
.PP
outputPacketCount
.PP
\ 
.SS Member Data Documentation
.PP
.SS \[u25C6]\ alertPacketCount
int yaidsPacketCounts_struct::alertPacketCount
.PP
.SS \[u25C6]\ outputPacketCount
int yaidsPacketCounts_struct::outputPacketCount
.PP
.SS \[u25C6]\ pcapPacketCount
int yaidsPacketCounts_struct::pcapPacketCount
.PP
.SS \[u25C6]\ yaraPacketCount
int yaidsPacketCounts_struct::yaraPacketCount
.PP
   *   *   *   *   *
.PP
The documentation for this struct was generated from the following file:
.IP \[bu] 2
include/yaidstypes.h
.PP
   *   *   *   *   *
.PP
Source Code Documentation Generated By \f[C]doxygen\f[R] \ 
.SH structyaidsPcapCallbackArgs__struct
.PP
YAIDS
.PP
yaidsPcapCallbackArgs_struct Struct Reference
.PP
\f[C]#include <yaidstypes.h>\f[R]
.PP
Collaboration diagram for yaidsPcapCallbackArgs_struct:
.PP
[IMAGE: Collaboration
graph (/images/structyaidsPcapCallbackArgs__struct__coll__graph.png)]
.SS  Public Attributes
.PP
yaidsInputDataQueue_ptr\ 
.PP
dataQueue
.PP
\ 
.PP
yaidsConfig_ptr\ 
.PP
config
.PP
\ 
.PP
yaidsPacketCounts_ptr\ 
.PP
packetCounts
.PP
\ 
.SS Member Data Documentation
.PP
.SS \[u25C6]\ config
yaidsConfig_ptr yaidsPcapCallbackArgs_struct::config
.PP
.SS \[u25C6]\ dataQueue
yaidsInputDataQueue_ptr yaidsPcapCallbackArgs_struct::dataQueue
.PP
.SS \[u25C6]\ packetCounts
yaidsPacketCounts_ptr yaidsPcapCallbackArgs_struct::packetCounts
.PP
   *   *   *   *   *
.PP
The documentation for this struct was generated from the following file:
.IP \[bu] 2
include/yaidstypes.h
.PP
   *   *   *   *   *
.PP
Source Code Documentation Generated By \f[C]doxygen\f[R] \ 
.SH structyaidsPcapHandle__struct
.PP
YAIDS
.PP
yaidsPcapHandle_struct Struct Reference
.PP
\f[C]#include <yaidstypes.h>\f[R]
.SS  Public Attributes
.PP
int\ 
.PP
threadId
.PP
\ 
.PP
int\ 
.PP
pcapStatus
.PP
\ 
.PP
int\ 
.PP
pcapTimeout
.PP
\ 
.PP
char\ 
.PP
errorBuffer [PCAP_ERRBUF_SIZE]
.PP
\ 
.PP
pcap_t *\ 
.PP
pcapHandle
.PP
\ 
.SS Member Data Documentation
.PP
.SS \[u25C6]\ errorBuffer
char yaidsPcapHandle_struct::errorBuffer[PCAP_ERRBUF_SIZE]
.PP
.SS \[u25C6]\ pcapHandle
pcap_t* yaidsPcapHandle_struct::pcapHandle
.PP
.SS \[u25C6]\ pcapStatus
int yaidsPcapHandle_struct::pcapStatus
.PP
.SS \[u25C6]\ pcapTimeout
int yaidsPcapHandle_struct::pcapTimeout
.PP
.SS \[u25C6]\ threadId
int yaidsPcapHandle_struct::threadId
.PP
   *   *   *   *   *
.PP
The documentation for this struct was generated from the following file:
.IP \[bu] 2
include/yaidstypes.h
.PP
   *   *   *   *   *
.PP
Source Code Documentation Generated By \f[C]doxygen\f[R] \ 
.SH structyaidsPcapPacketHeaderFrame__struct
.PP
YAIDS
.PP
yaidsPcapPacketHeaderFrame_struct Struct Reference
.PP
\f[C]#include <yaidstypes.h>\f[R]
.SS  Public Attributes
.PP
char\ 
.PP
type [14]
.PP
\ 
.PP
char\ 
.PP
source [INET6_ADDRSTRLEN+1]
.PP
\ 
.PP
char\ 
.PP
dest [INET6_ADDRSTRLEN+1]
.PP
\ 
.SS Member Data Documentation
.PP
.SS \[u25C6]\ dest
char yaidsPcapPacketHeaderFrame_struct::dest[INET6_ADDRSTRLEN+1]
.PP
.SS \[u25C6]\ source
char yaidsPcapPacketHeaderFrame_struct::source[INET6_ADDRSTRLEN+1]
.PP
.SS \[u25C6]\ type
char yaidsPcapPacketHeaderFrame_struct::type[14]
.PP
   *   *   *   *   *
.PP
The documentation for this struct was generated from the following file:
.IP \[bu] 2
include/yaidstypes.h
.PP
   *   *   *   *   *
.PP
Source Code Documentation Generated By \f[C]doxygen\f[R] \ 
.SH structyaidsPcapPacketHeaderNet__struct
.PP
YAIDS
.PP
yaidsPcapPacketHeaderNet_struct Struct Reference
.PP
\f[C]#include <yaidstypes.h>\f[R]
.SS  Public Attributes
.PP
char\ 
.PP
type [14]
.PP
\ 
.PP
char\ 
.PP
source [INET6_ADDRSTRLEN+1]
.PP
\ 
.PP
char\ 
.PP
dest [INET6_ADDRSTRLEN+1]
.PP
\ 
.SS Member Data Documentation
.PP
.SS \[u25C6]\ dest
char yaidsPcapPacketHeaderNet_struct::dest[INET6_ADDRSTRLEN+1]
.PP
.SS \[u25C6]\ source
char yaidsPcapPacketHeaderNet_struct::source[INET6_ADDRSTRLEN+1]
.PP
.SS \[u25C6]\ type
char yaidsPcapPacketHeaderNet_struct::type[14]
.PP
   *   *   *   *   *
.PP
The documentation for this struct was generated from the following file:
.IP \[bu] 2
include/yaidstypes.h
.PP
   *   *   *   *   *
.PP
Source Code Documentation Generated By \f[C]doxygen\f[R] \ 
.SH structyaidsPcapPacketHeaderTransport__struct
.PP
YAIDS
.PP
yaidsPcapPacketHeaderTransport_struct Struct Reference
.PP
\f[C]#include <yaidstypes.h>\f[R]
.SS  Public Attributes
.PP
char\ 
.PP
type [14]
.PP
\ 
.PP
char\ 
.PP
source [10]
.PP
\ 
.PP
char\ 
.PP
dest [10]
.PP
\ 
.SS Member Data Documentation
.PP
.SS \[u25C6]\ dest
char yaidsPcapPacketHeaderTransport_struct::dest[10]
.PP
.SS \[u25C6]\ source
char yaidsPcapPacketHeaderTransport_struct::source[10]
.PP
.SS \[u25C6]\ type
char yaidsPcapPacketHeaderTransport_struct::type[14]
.PP
   *   *   *   *   *
.PP
The documentation for this struct was generated from the following file:
.IP \[bu] 2
include/yaidstypes.h
.PP
   *   *   *   *   *
.PP
Source Code Documentation Generated By \f[C]doxygen\f[R] \ 
.SH structyaidsPcapPacketHeader__struct
.PP
YAIDS
.PP
yaidsPcapPacketHeader_struct Struct Reference
.PP
\f[C]#include <yaidstypes.h>\f[R]
.SS  Public Attributes
.PP
bool\ 
.PP
frameExists
.PP
\ 
.PP
bool\ 
.PP
netExists
.PP
\ 
.PP
bool\ 
.PP
transportExists
.PP
\ 
.PP
char\ 
.PP
typeList [42]
.PP
\ 
.PP
char\ 
.PP
frameSource [INET6_ADDRSTRLEN+1]
.PP
\ 
.PP
char\ 
.PP
frameDest [INET6_ADDRSTRLEN+1]
.PP
\ 
.PP
char\ 
.PP
netSource [INET6_ADDRSTRLEN+1]
.PP
\ 
.PP
char\ 
.PP
netDest [INET6_ADDRSTRLEN+1]
.PP
\ 
.PP
char\ 
.PP
transportSource [10]
.PP
\ 
.PP
char\ 
.PP
transportDest [10]
.PP
\ 
.SS Member Data Documentation
.PP
.SS \[u25C6]\ frameDest
char yaidsPcapPacketHeader_struct::frameDest[INET6_ADDRSTRLEN+1]
.PP
.SS \[u25C6]\ frameExists
bool yaidsPcapPacketHeader_struct::frameExists
.PP
.SS \[u25C6]\ frameSource
char yaidsPcapPacketHeader_struct::frameSource[INET6_ADDRSTRLEN+1]
.PP
.SS \[u25C6]\ netDest
char yaidsPcapPacketHeader_struct::netDest[INET6_ADDRSTRLEN+1]
.PP
.SS \[u25C6]\ netExists
bool yaidsPcapPacketHeader_struct::netExists
.PP
.SS \[u25C6]\ netSource
char yaidsPcapPacketHeader_struct::netSource[INET6_ADDRSTRLEN+1]
.PP
.SS \[u25C6]\ transportDest
char yaidsPcapPacketHeader_struct::transportDest[10]
.PP
.SS \[u25C6]\ transportExists
bool yaidsPcapPacketHeader_struct::transportExists
.PP
.SS \[u25C6]\ transportSource
char yaidsPcapPacketHeader_struct::transportSource[10]
.PP
.SS \[u25C6]\ typeList
char yaidsPcapPacketHeader_struct::typeList[42]
.PP
   *   *   *   *   *
.PP
The documentation for this struct was generated from the following file:
.IP \[bu] 2
include/yaidstypes.h
.PP
   *   *   *   *   *
.PP
Source Code Documentation Generated By \f[C]doxygen\f[R] \ 
.SH structyaidsPcapPacket__struct
.PP
YAIDS
.PP
yaidsPcapPacket_struct Struct Reference
.PP
\f[C]#include <yaidstypes.h>\f[R]
.SS  Public Attributes
.PP
bool\ 
.PP
alert
.PP
\ 
.PP
int\ 
.PP
packetSize
.PP
\ 
.PP
const struct pcap_pkthdr *\ 
.PP
packetHeader
.PP
\ 
.PP
const u_char *\ 
.PP
packetBody
.PP
\ 
.SS Member Data Documentation
.PP
.SS \[u25C6]\ alert
bool yaidsPcapPacket_struct::alert
.PP
.SS \[u25C6]\ packetBody
const u_char* yaidsPcapPacket_struct::packetBody
.PP
.SS \[u25C6]\ packetHeader
const struct pcap_pkthdr* yaidsPcapPacket_struct::packetHeader
.PP
.SS \[u25C6]\ packetSize
int yaidsPcapPacket_struct::packetSize
.PP
   *   *   *   *   *
.PP
The documentation for this struct was generated from the following file:
.IP \[bu] 2
include/yaidstypes.h
.PP
   *   *   *   *   *
.PP
Source Code Documentation Generated By \f[C]doxygen\f[R] \ 
.SH structyaidsThreadInfo__struct
.PP
YAIDS
.PP
yaidsThreadInfo_struct Struct Reference
.PP
\f[C]#include <yaidstypes.h>\f[R]
.SS  Public Attributes
.PP
pthread_t\ 
.PP
threadId
.PP
\ 
.PP
int\ 
.PP
threadType
.PP
\ 
.SS Member Data Documentation
.PP
.SS \[u25C6]\ threadId
pthread_t yaidsThreadInfo_struct::threadId
.PP
.SS \[u25C6]\ threadType
int yaidsThreadInfo_struct::threadType
.PP
   *   *   *   *   *
.PP
The documentation for this struct was generated from the following file:
.IP \[bu] 2
include/yaidstypes.h
.PP
   *   *   *   *   *
.PP
Source Code Documentation Generated By \f[C]doxygen\f[R] \ 
.SH structyaidsThreadList__struct
.PP
YAIDS
.PP
yaidsThreadList_struct Struct Reference
.PP
\f[C]#include <yaidstypes.h>\f[R]
.PP
Collaboration diagram for yaidsThreadList_struct:
.PP
[IMAGE: Collaboration
graph (/images/structyaidsThreadList__struct__coll__graph.png)]
.SS  Public Attributes
.PP
yaidsThreadInfo_ptr\ 
.PP
threadInfo
.PP
\ 
.SS Member Data Documentation
.PP
.SS \[u25C6]\ threadInfo
yaidsThreadInfo_ptr yaidsThreadList_struct::threadInfo
.PP
   *   *   *   *   *
.PP
The documentation for this struct was generated from the following file:
.IP \[bu] 2
include/yaidstypes.h
.PP
   *   *   *   *   *
.PP
Source Code Documentation Generated By \f[C]doxygen\f[R] \ 
.SH structyaidsThreadReturn__struct
.PP
YAIDS
.PP
yaidsThreadReturn_struct Struct Reference
.PP
\f[C]#include <yaidstypes.h>\f[R]
.SS  Public Attributes
.PP
pthread_t\ 
.PP
threadId
.PP
\ 
.PP
int\ 
.PP
threadStatus
.PP
\ 
.SS Member Data Documentation
.PP
.SS \[u25C6]\ threadId
pthread_t yaidsThreadReturn_struct::threadId
.PP
.SS \[u25C6]\ threadStatus
int yaidsThreadReturn_struct::threadStatus
.PP
   *   *   *   *   *
.PP
The documentation for this struct was generated from the following file:
.IP \[bu] 2
include/yaidstypes.h
.PP
   *   *   *   *   *
.PP
Source Code Documentation Generated By \f[C]doxygen\f[R] \ 
.SH structyaidsThreadStatuses__struct
.PP
YAIDS
.PP
yaidsThreadStatuses_struct Struct Reference
.PP
\f[C]#include <yaidstypes.h>\f[R]
.SS  Public Attributes
.PP
bool\ 
.PP
pcapThreadsFinished
.PP
\ 
.PP
bool\ 
.PP
yaraThreadsFinished
.PP
\ 
.PP
bool\ 
.PP
outputThreadsFinished
.PP
\ 
.SS Member Data Documentation
.PP
.SS \[u25C6]\ outputThreadsFinished
bool yaidsThreadStatuses_struct::outputThreadsFinished
.PP
.SS \[u25C6]\ pcapThreadsFinished
bool yaidsThreadStatuses_struct::pcapThreadsFinished
.PP
.SS \[u25C6]\ yaraThreadsFinished
bool yaidsThreadStatuses_struct::yaraThreadsFinished
.PP
   *   *   *   *   *
.PP
The documentation for this struct was generated from the following file:
.IP \[bu] 2
include/yaidstypes.h
.PP
   *   *   *   *   *
.PP
Source Code Documentation Generated By \f[C]doxygen\f[R] \ 
.SH structyaidsTimelimitThreadArgs__struct
.PP
YAIDS
.PP
yaidsTimelimitThreadArgs_struct Struct Reference
.PP
\f[C]#include <yaidstypes.h>\f[R]
.PP
Collaboration diagram for yaidsTimelimitThreadArgs_struct:
.PP
[IMAGE: Collaboration
graph (/images/structyaidsTimelimitThreadArgs__struct__coll__graph.png)]
.SS  Public Attributes
.PP
bool *\ 
.PP
yaidsRunning
.PP
\ 
.PP
yaidsConfig_ptr\ 
.PP
config
.PP
\ 
.SS Member Data Documentation
.PP
.SS \[u25C6]\ config
yaidsConfig_ptr yaidsTimelimitThreadArgs_struct::config
.PP
.SS \[u25C6]\ yaidsRunning
bool* yaidsTimelimitThreadArgs_struct::yaidsRunning
.PP
   *   *   *   *   *
.PP
The documentation for this struct was generated from the following file:
.IP \[bu] 2
include/yaidstypes.h
.PP
   *   *   *   *   *
.PP
Source Code Documentation Generated By \f[C]doxygen\f[R] \ 
.SH structyaidsYaraCallbackArgs__struct
.PP
YAIDS
.PP
yaidsYaraCallbackArgs_struct Struct Reference
.PP
\f[C]#include <yaidstypes.h>\f[R]
.PP
Collaboration diagram for yaidsYaraCallbackArgs_struct:
.PP
[IMAGE: Collaboration
graph (/images/structyaidsYaraCallbackArgs__struct__coll__graph.png)]
.SS  Public Attributes
.PP
yaidsPcapPacket_ptr\ 
.PP
packet
.PP
\ 
.PP
yaidsOutputDataQueue_ptr\ 
.PP
outputDataQueue
.PP
\ 
.PP
yaidsConfig_ptr\ 
.PP
config
.PP
\ 
.PP
yaidsPacketCounts_ptr\ 
.PP
packetCounts
.PP
\ 
.SS Member Data Documentation
.PP
.SS \[u25C6]\ config
yaidsConfig_ptr yaidsYaraCallbackArgs_struct::config
.PP
.SS \[u25C6]\ outputDataQueue
yaidsOutputDataQueue_ptr yaidsYaraCallbackArgs_struct::outputDataQueue
.PP
.SS \[u25C6]\ packet
yaidsPcapPacket_ptr yaidsYaraCallbackArgs_struct::packet
.PP
.SS \[u25C6]\ packetCounts
yaidsPacketCounts_ptr yaidsYaraCallbackArgs_struct::packetCounts
.PP
   *   *   *   *   *
.PP
The documentation for this struct was generated from the following file:
.IP \[bu] 2
include/yaidstypes.h
.PP
   *   *   *   *   *
.PP
Source Code Documentation Generated By \f[C]doxygen\f[R] \ 
.SH structyaidsYaraScanner__struct
.PP
YAIDS
.PP
yaidsYaraScanner_struct Struct Reference
.PP
\f[C]#include <yaidstypes.h>\f[R]
.SS  Public Attributes
.PP
int\ 
.PP
threadId
.PP
\ 
.PP
YR_RULES *\ 
.PP
yaraRules
.PP
\ 
.PP
YR_SCANNER *\ 
.PP
yaraScanner
.PP
\ 
.SS Member Data Documentation
.PP
.SS \[u25C6]\ threadId
int yaidsYaraScanner_struct::threadId
.PP
.SS \[u25C6]\ yaraRules
YR_RULES* yaidsYaraScanner_struct::yaraRules
.PP
.SS \[u25C6]\ yaraScanner
YR_SCANNER* yaidsYaraScanner_struct::yaraScanner
.PP
   *   *   *   *   *
.PP
The documentation for this struct was generated from the following file:
.IP \[bu] 2
include/yaidstypes.h
.PP
   *   *   *   *   *
.PP
Source Code Documentation Generated By \f[C]doxygen\f[R] \ 
.SH structyaidsYaraThreadArgs__struct
.PP
YAIDS
.PP
yaidsYaraThreadArgs_struct Struct Reference
.PP
\f[C]#include <yaidstypes.h>\f[R]
.PP
Collaboration diagram for yaidsYaraThreadArgs_struct:
.PP
[IMAGE: Collaboration
graph (/images/structyaidsYaraThreadArgs__struct__coll__graph.png)]
.SS  Public Attributes
.PP
yaidsInputDataQueue_ptr\ 
.PP
inputDataQueue
.PP
\ 
.PP
yaidsOutputDataQueue_ptr\ 
.PP
outputDataQueue
.PP
\ 
.PP
yaidsYaraScanner_ptr\ 
.PP
yaraScanner
.PP
\ 
.PP
yaidsConfig_ptr\ 
.PP
config
.PP
\ 
.PP
yaidsPacketCounts_ptr\ 
.PP
packetCounts
.PP
\ 
.PP
yaidsThreadStatuses_ptr\ 
.PP
threadStatuses
.PP
\ 
.SS Member Data Documentation
.PP
.SS \[u25C6]\ config
yaidsConfig_ptr yaidsYaraThreadArgs_struct::config
.PP
.SS \[u25C6]\ inputDataQueue
yaidsInputDataQueue_ptr yaidsYaraThreadArgs_struct::inputDataQueue
.PP
.SS \[u25C6]\ outputDataQueue
yaidsOutputDataQueue_ptr yaidsYaraThreadArgs_struct::outputDataQueue
.PP
.SS \[u25C6]\ packetCounts
yaidsPacketCounts_ptr yaidsYaraThreadArgs_struct::packetCounts
.PP
.SS \[u25C6]\ threadStatuses
yaidsThreadStatuses_ptr yaidsYaraThreadArgs_struct::threadStatuses
.PP
.SS \[u25C6]\ yaraScanner
yaidsYaraScanner_ptr yaidsYaraThreadArgs_struct::yaraScanner
.PP
   *   *   *   *   *
.PP
The documentation for this struct was generated from the following file:
.IP \[bu] 2
include/yaidstypes.h
.PP
   *   *   *   *   *
.PP
Source Code Documentation Generated By \f[C]doxygen\f[R] \ 
.SH ethertypes
.PP
YAIDS
.PP
Macros
.PP
ethertypes.h File Reference
.SS  Macros
.PP
#define\ 
.PP
ETHERTYPE_PUP\ \ \ 0x0200
.PP
\ 
.PP
#define\ 
.PP
ETHERTYPE_IP\ \ \ 0x0800
.PP
\ 
.PP
#define\ 
.PP
ETHERTYPE_ARP\ \ \ 0x0806
.PP
\ 
.PP
#define\ 
.PP
ETHERTYPE_REVARP\ \ \ 0x8035
.PP
\ 
.PP
#define\ 
.PP
ETHERTYPE_NS\ \ \ 0x0600
.PP
\ 
.PP
#define\ 
.PP
ETHERTYPE_SPRITE\ \ \ 0x0500
.PP
\ 
.PP
#define\ 
.PP
ETHERTYPE_TRAIL\ \ \ 0x1000
.PP
\ 
.PP
#define\ 
.PP
ETHERTYPE_MOPDL\ \ \ 0x6001
.PP
\ 
.PP
#define\ 
.PP
ETHERTYPE_MOPRC\ \ \ 0x6002
.PP
\ 
.PP
#define\ 
.PP
ETHERTYPE_DN\ \ \ 0x6003
.PP
\ 
.PP
#define\ 
.PP
ETHERTYPE_LAT\ \ \ 0x6004
.PP
\ 
.PP
#define\ 
.PP
ETHERTYPE_SCA\ \ \ 0x6007
.PP
\ 
.PP
#define\ 
.PP
ETHERTYPE_TEB\ \ \ 0x6558
.PP
\ 
.PP
#define\ 
.PP
ETHERTYPE_LANBRIDGE\ \ \ 0x8038
.PP
\ 
.PP
#define\ 
.PP
ETHERTYPE_DECDNS\ \ \ 0x803c
.PP
\ 
.PP
#define\ 
.PP
ETHERTYPE_DECDTS\ \ \ 0x803e
.PP
\ 
.PP
#define\ 
.PP
ETHERTYPE_VEXP\ \ \ 0x805b
.PP
\ 
.PP
#define\ 
.PP
ETHERTYPE_VPROD\ \ \ 0x805c
.PP
\ 
.PP
#define\ 
.PP
ETHERTYPE_ATALK\ \ \ 0x809b
.PP
\ 
.PP
#define\ 
.PP
ETHERTYPE_AARP\ \ \ 0x80f3
.PP
\ 
.PP
#define\ 
.PP
ETHERTYPE_8021Q\ \ \ 0x8100
.PP
\ 
.PP
#define\ 
.PP
ETHERTYPE_IPX\ \ \ 0x8137
.PP
\ 
.PP
#define\ 
.PP
ETHERTYPE_IPV6\ \ \ 0x86dd
.PP
\ 
.PP
#define\ 
.PP
ETHERTYPE_MPLS\ \ \ 0x8847
.PP
\ 
.PP
#define\ 
.PP
ETHERTYPE_MPLS_MULTI\ \ \ 0x8848
.PP
\ 
.PP
#define\ 
.PP
ETHERTYPE_PPP\ \ \ 0x880b
.PP
\ 
.PP
#define\ 
.PP
ETHERTYPE_PPPOED\ \ \ 0x8863
.PP
\ 
.PP
#define\ 
.PP
ETHERTYPE_PPPOES\ \ \ 0x8864
.PP
\ 
.PP
#define\ 
.PP
ETHERTYPE_8021AD\ \ \ 0x88a8
.PP
\ 
.PP
#define\ 
.PP
ETHERTYPE_LOOPBACK\ \ \ 0x9000
.PP
\ 
.PP
#define\ 
.PP
ETHERTYPE_8021QINQ\ \ \ 0x9100
.PP
\ 
.SS Macro Definition Documentation
.PP
.SS \[u25C6]\ ETHERTYPE_8021AD
#define ETHERTYPE_8021AD\ \ \ 0x88a8
.PP
.SS \[u25C6]\ ETHERTYPE_8021Q
#define ETHERTYPE_8021Q\ \ \ 0x8100
.PP
.SS \[u25C6]\ ETHERTYPE_8021QINQ
#define ETHERTYPE_8021QINQ\ \ \ 0x9100
.PP
.SS \[u25C6]\ ETHERTYPE_AARP
#define ETHERTYPE_AARP\ \ \ 0x80f3
.PP
.SS \[u25C6]\ ETHERTYPE_ARP
#define ETHERTYPE_ARP\ \ \ 0x0806
.PP
.SS \[u25C6]\ ETHERTYPE_ATALK
#define ETHERTYPE_ATALK\ \ \ 0x809b
.PP
.SS \[u25C6]\ ETHERTYPE_DECDNS
#define ETHERTYPE_DECDNS\ \ \ 0x803c
.PP
.SS \[u25C6]\ ETHERTYPE_DECDTS
#define ETHERTYPE_DECDTS\ \ \ 0x803e
.PP
.SS \[u25C6]\ ETHERTYPE_DN
#define ETHERTYPE_DN\ \ \ 0x6003
.PP
.SS \[u25C6]\ ETHERTYPE_IP
#define ETHERTYPE_IP\ \ \ 0x0800
.PP
.SS \[u25C6]\ ETHERTYPE_IPV6
#define ETHERTYPE_IPV6\ \ \ 0x86dd
.PP
.SS \[u25C6]\ ETHERTYPE_IPX
#define ETHERTYPE_IPX\ \ \ 0x8137
.PP
.SS \[u25C6]\ ETHERTYPE_LANBRIDGE
#define ETHERTYPE_LANBRIDGE\ \ \ 0x8038
.PP
.SS \[u25C6]\ ETHERTYPE_LAT
#define ETHERTYPE_LAT\ \ \ 0x6004
.PP
.SS \[u25C6]\ ETHERTYPE_LOOPBACK
#define ETHERTYPE_LOOPBACK\ \ \ 0x9000
.PP
.SS \[u25C6]\ ETHERTYPE_MOPDL
#define ETHERTYPE_MOPDL\ \ \ 0x6001
.PP
.SS \[u25C6]\ ETHERTYPE_MOPRC
#define ETHERTYPE_MOPRC\ \ \ 0x6002
.PP
.SS \[u25C6]\ ETHERTYPE_MPLS
#define ETHERTYPE_MPLS\ \ \ 0x8847
.PP
.SS \[u25C6]\ ETHERTYPE_MPLS_MULTI
#define ETHERTYPE_MPLS_MULTI\ \ \ 0x8848
.PP
.SS \[u25C6]\ ETHERTYPE_NS
#define ETHERTYPE_NS\ \ \ 0x0600
.PP
.SS \[u25C6]\ ETHERTYPE_PPP
#define ETHERTYPE_PPP\ \ \ 0x880b
.PP
.SS \[u25C6]\ ETHERTYPE_PPPOED
#define ETHERTYPE_PPPOED\ \ \ 0x8863
.PP
.SS \[u25C6]\ ETHERTYPE_PPPOES
#define ETHERTYPE_PPPOES\ \ \ 0x8864
.PP
.SS \[u25C6]\ ETHERTYPE_PUP
#define ETHERTYPE_PUP\ \ \ 0x0200
.PP
.SS \[u25C6]\ ETHERTYPE_REVARP
#define ETHERTYPE_REVARP\ \ \ 0x8035
.PP
.SS \[u25C6]\ ETHERTYPE_SCA
#define ETHERTYPE_SCA\ \ \ 0x6007
.PP
.SS \[u25C6]\ ETHERTYPE_SPRITE
#define ETHERTYPE_SPRITE\ \ \ 0x0500
.PP
.SS \[u25C6]\ ETHERTYPE_TEB
#define ETHERTYPE_TEB\ \ \ 0x6558
.PP
.SS \[u25C6]\ ETHERTYPE_TRAIL
#define ETHERTYPE_TRAIL\ \ \ 0x1000
.PP
.SS \[u25C6]\ ETHERTYPE_VEXP
#define ETHERTYPE_VEXP\ \ \ 0x805b
.PP
.SS \[u25C6]\ ETHERTYPE_VPROD
#define ETHERTYPE_VPROD\ \ \ 0x805c
.PP
   *   *   *   *   *
.PP
Source Code Documentation Generated By \f[C]doxygen\f[R] \ 
.SH yaids
.PP
YAIDS
.PP
Macros | Functions | Variables
.PP
yaids.h File Reference
.PP
\f[C]#include <stdbool.h>\f[R]
.PP
Include dependency graph for yaids.h:
.PP

.SS  Macros
.PP
#define\ 
.PP
YAIDS_SUCCESS\ \ \ 0
.PP
\ 
.PP
#define\ 
.PP
YAIDS_ERROR\ \ \ 1
.PP
\ 
.PP
#define\ 
.PP
YAIDS_PENDING_CONFIG\ \ \ 2
.PP
\ 
.PP
#define\ 
.PP
YAIDS_MISSING_ARGUMENTS\ \ \ 2
.PP
\ 
.PP
#define\ 
.PP
YAIDS_INVALID_ARGUMENTS\ \ \ 3
.PP
\ 
.PP
#define\ 
.PP
YAIDS_INVALID_MODE\ \ \ 4
.PP
\ 
.PP
#define\ 
.PP
YAIDS_NO_ACTION\ \ \ 10
.PP
\ 
.PP
#define\ 
.PP
YAIDS_PERMISSION_DENIED\ \ \ 20
.PP
\ 
.PP
#define\ 
.PP
YAIDS_FILE_DOES_NOT_EXIST\ \ \ 21
.PP
\ 
.PP
#define\ 
.PP
YAIDS_THREAD_ERROR\ \ \ 30
.PP
\ 
.PP
#define\ 
.PP
YAIDS_PCAP_ERROR\ \ \ 40
.PP
\ 
.PP
#define\ 
.PP
YAIDS_PCAP_DEVICE_DOES_NOT_EXIST\ \ \ 41
.PP
\ 
.PP
#define\ 
.PP
YAIDS_YARA_ERROR\ \ \ 50
.PP
\ 
.PP
#define\ 
.PP
YAIDS_YARA_MATCH\ \ \ 100
.PP
\ 
.PP
#define\ 
.PP
YAIDS_YARA_NOMATCH\ \ \ 101
.PP
\ 
.PP
#define\ 
.PP
YAIDS_COMPLETE\ \ \ 999
.PP
\ 
.PP
#define\ 
.PP
sec_str_cpy\ \ \ strncpy
.PP
\ 
.SS  Functions
.PP
void\ 
.PP
yaids_signal (int signalValue)
.PP
\ 
.PP
bool\ 
.PP
verify_status (int statusCode)
.PP
\ 
.PP
int\ 
.PP
main (int argc, char **argv)
.PP
\ 
.SS  Variables
.PP
const char *\ 
.PP
PROGRAM_NAME
.PP
\ 
.PP
const char *\ 
.PP
COPYRIGHT
.PP
\ 
.PP
const char *\ 
.PP
PROGRAM_SUBLINE
.PP
\ 
.PP
const char *\ 
.PP
PROGRAM_DESCRIPTION
.PP
\ 
.PP
const char *\ 
.PP
PROGRAM_VERSION
.PP
\ 
.PP
bool\ 
.PP
global_yaidsRunning
.PP
\ 
.SS Macro Definition Documentation
.PP
.SS \[u25C6]\ sec_str_cpy
#define sec_str_cpy\ \ \ strncpy
.PP
.SS \[u25C6]\ YAIDS_COMPLETE
#define YAIDS_COMPLETE\ \ \ 999
.PP
.SS \[u25C6]\ YAIDS_ERROR
#define YAIDS_ERROR\ \ \ 1
.PP
.SS \[u25C6]\ YAIDS_FILE_DOES_NOT_EXIST
#define YAIDS_FILE_DOES_NOT_EXIST\ \ \ 21
.PP
.SS \[u25C6]\ YAIDS_INVALID_ARGUMENTS
#define YAIDS_INVALID_ARGUMENTS\ \ \ 3
.PP
.SS \[u25C6]\ YAIDS_INVALID_MODE
#define YAIDS_INVALID_MODE\ \ \ 4
.PP
.SS \[u25C6]\ YAIDS_MISSING_ARGUMENTS
#define YAIDS_MISSING_ARGUMENTS\ \ \ 2
.PP
.SS \[u25C6]\ YAIDS_NO_ACTION
#define YAIDS_NO_ACTION\ \ \ 10
.PP
.SS \[u25C6]\ YAIDS_PCAP_DEVICE_DOES_NOT_EXIST
#define YAIDS_PCAP_DEVICE_DOES_NOT_EXIST\ \ \ 41
.PP
.SS \[u25C6]\ YAIDS_PCAP_ERROR
#define YAIDS_PCAP_ERROR\ \ \ 40
.PP
.SS \[u25C6]\ YAIDS_PENDING_CONFIG
#define YAIDS_PENDING_CONFIG\ \ \ 2
.PP
.SS \[u25C6]\ YAIDS_PERMISSION_DENIED
#define YAIDS_PERMISSION_DENIED\ \ \ 20
.PP
.SS \[u25C6]\ YAIDS_SUCCESS
#define YAIDS_SUCCESS\ \ \ 0
.PP
.SS \[u25C6]\ YAIDS_THREAD_ERROR
#define YAIDS_THREAD_ERROR\ \ \ 30
.PP
.SS \[u25C6]\ YAIDS_YARA_ERROR
#define YAIDS_YARA_ERROR\ \ \ 50
.PP
.SS \[u25C6]\ YAIDS_YARA_MATCH
#define YAIDS_YARA_MATCH\ \ \ 100
.PP
.SS \[u25C6]\ YAIDS_YARA_NOMATCH
#define YAIDS_YARA_NOMATCH\ \ \ 101
.SS Function Documentation
.PP
.SS \[u25C6]\ main()
int main
(
int\ 
argc,
char **\ 
argv\ 
)
.PP
.SS \[u25C6]\ verify_status()
bool verify_status
(
int\ 
statusCode
)
.PP
.SS \[u25C6]\ yaids_signal()
void yaids_signal
(
int\ 
signalValue
)
.SS Variable Documentation
.PP
.SS \[u25C6]\ COPYRIGHT
const char* COPYRIGHT
.PP
.SS \[u25C6]\ global_yaidsRunning
bool global_yaidsRunning
.PP
.SS \[u25C6]\ PROGRAM_DESCRIPTION
const char* PROGRAM_DESCRIPTION
.PP
.SS \[u25C6]\ PROGRAM_NAME
const char* PROGRAM_NAME
.PP
.SS \[u25C6]\ PROGRAM_SUBLINE
const char* PROGRAM_SUBLINE
.PP
.SS \[u25C6]\ PROGRAM_VERSION
const char* PROGRAM_VERSION
.PP
   *   *   *   *   *
.PP
Source Code Documentation Generated By \f[C]doxygen\f[R] \ 
.SH yaidsconf
.PP
YAIDS
.PP
Functions
.PP
yaidsconf.h File Reference
.SS  Functions
.PP
yaidsConfig\ 
.PP
yaidsconf_init (void)
.PP
\ 
.PP
int\ 
.PP
yaidsconf_get_default_thread_count (void)
.PP
\ 
.PP
void\ 
.PP
yaidsconf_config_init (yaidsConfig_ptr config, char *exeName, int
options)
.PP
\ 
.SS Function Documentation
.PP
.SS \[u25C6]\ yaidsconf_config_init()
void yaidsconf_config_init
(
yaidsConfig_ptr\ 
config,
char *\ 
exeName,
int\ 
options\ 
)
.PP
.SS \[u25C6]\ yaidsconf_get_default_thread_count()
int yaidsconf_get_default_thread_count
(
void\ 
)
.PP
.SS \[u25C6]\ yaidsconf_init()
yaidsConfig yaidsconf_init
(
void\ 
)
.PP
   *   *   *   *   *
.PP
Source Code Documentation Generated By \f[C]doxygen\f[R] \ 
.SH yaidsio
.PP
YAIDS
.PP
Functions
.PP
yaidsio.h File Reference
.SS  Functions
.PP
void\ 
.PP
yaidsio_print_debug_line (const char *format,\&...)
.PP
\ 
.PP
void\ 
.PP
yaidsio_print_error_line (const char *format,\&...)
.PP
\ 
.PP
void\ 
.PP
yaidsio_print_std_line (const char *format,\&...)
.PP
\ 
.PP
void\ 
.PP
yaidsio_print_horizontal_line (int chars)
.PP
\ 
.PP
void\ 
.PP
yaidsio_print_header (void)
.PP
\ 
.PP
void\ 
.PP
yaidsio_print_arg_line (char *opt, char *type, char *desc)
.PP
\ 
.PP
void\ 
.PP
yaidsio_help (char *exe)
.PP
\ 
.PP
void\ 
.PP
yaidsio_version (void)
.PP
\ 
.PP
yaidsConfig\ 
.PP
yaidsio_getopts (int argc, char **argv)
.PP
\ 
.PP
void\ 
.PP
yaidsio_print_config_debug (yaidsConfig_ptr config)
.PP
\ 
.PP
void\ 
.PP
yaidsio_exit_error (int errorCode)
.PP
\ 
.PP
void\ 
.PP
yaidsio_print_started (void)
.PP
\ 
.PP
void\ 
.PP
yaidsio_print_exiting (void)
.PP
\ 
.PP
void\ 
.PP
yaidsio_print_alert (char *alert)
.PP
\ 
.PP
void\ 
.PP
yaidsio_write_alert (FILE *alertFileHandle, char *alert)
.PP
\ 
.PP
void\ 
.PP
yaidsio_write_pcap (FILE *pcapFileHandle, yaidsPcapPacket_ptr packet)
.PP
\ 
.SS Function Documentation
.PP
.SS \[u25C6]\ yaidsio_exit_error()
void yaidsio_exit_error
(
int\ 
errorCode
)
.PP
.SS \[u25C6]\ yaidsio_getopts()
yaidsConfig yaidsio_getopts
(
int\ 
argc,
char **\ 
argv\ 
)
.PP
.SS \[u25C6]\ yaidsio_help()
void yaidsio_help
(
char *\ 
exe
)
.PP
.SS \[u25C6]\ yaidsio_print_alert()
void yaidsio_print_alert
(
char *\ 
alert
)
.PP
.SS \[u25C6]\ yaidsio_print_arg_line()
void yaidsio_print_arg_line
(
char *\ 
opt,
char *\ 
type,
char *\ 
desc\ 
)
.PP
.SS \[u25C6]\ yaidsio_print_config_debug()
void yaidsio_print_config_debug
(
yaidsConfig_ptr\ 
config
)
.PP
.SS \[u25C6]\ yaidsio_print_debug_line()
void yaidsio_print_debug_line
(
const char *\ 
format,
\ 
\&...\ 
)
.PP
.SS \[u25C6]\ yaidsio_print_error_line()
void yaidsio_print_error_line
(
const char *\ 
format,
\ 
\&...\ 
)
.PP
.SS \[u25C6]\ yaidsio_print_exiting()
void yaidsio_print_exiting
(
void\ 
)
.PP
.SS \[u25C6]\ yaidsio_print_header()
void yaidsio_print_header
(
void\ 
)
.PP
.SS \[u25C6]\ yaidsio_print_horizontal_line()
void yaidsio_print_horizontal_line
(
int\ 
chars
)
.PP
.SS \[u25C6]\ yaidsio_print_started()
void yaidsio_print_started
(
void\ 
)
.PP
.SS \[u25C6]\ yaidsio_print_std_line()
void yaidsio_print_std_line
(
const char *\ 
format,
\ 
\&...\ 
)
.PP
.SS \[u25C6]\ yaidsio_version()
void yaidsio_version
(
void\ 
)
.PP
.SS \[u25C6]\ yaidsio_write_alert()
void yaidsio_write_alert
(
FILE *\ 
alertFileHandle,
char *\ 
alert\ 
)
.PP
.SS \[u25C6]\ yaidsio_write_pcap()
void yaidsio_write_pcap
(
FILE *\ 
pcapFileHandle,
yaidsPcapPacket_ptr\ 
packet\ 
)
.PP
   *   *   *   *   *
.PP
Source Code Documentation Generated By \f[C]doxygen\f[R] \ 
.SH yaidspcap
.PP
YAIDS
.PP
Macros | Functions
.PP
yaidspcap.h File Reference
.PP
\f[C]#include <pcap.h>\f[R]
.PP
Include dependency graph for yaidspcap.h:
.PP

.SS  Macros
.PP
#define\ 
.PP
ETH_HEADER_SIZE\ \ \ 14
.PP
\ 
.SS  Functions
.PP
void\ 
.PP
yaidspcap_init (yaidsPcapHandle_ptr pcapHandle)
.PP
\ 
.PP
yaidsPcapPacket_ptr\ 
.PP
yaidspcap_new_packet (int size)
.PP
\ 
.PP
int\ 
.PP
yaidspcap_create_handle (yaidsConfig_ptr config, yaidsPcapHandle_ptr
pcapHandle)
.PP
\ 
.PP
void\ 
.PP
yaidspcap_read_packets (yaidsPcapHandle_ptr pcapHandle,
yaidsPcapCallbackArgs_ptr callbackArgs)
.PP
\ 
.PP
void\ 
.PP
yaidspcap_read_callback (u_char *args, const struct pcap_pkthdr
*packetHeader, const u_char *packetBody)
.PP
\ 
.PP
yaidsPcapPacketHeaderFrame_ptr\ 
.PP
yaidspcap_parse_pcap_headers_frame (etherHeader_ptr etherHeader)
.PP
\ 
.PP
yaidsPcapPacketHeaderNet_ptr\ 
.PP
yaidspcap_parse_pcap_headers_net (etherHeader_ptr etherHeader,
ipHeader_ptr ipHeader)
.PP
\ 
.PP
yaidsPcapPacketHeaderTransport_ptr\ 
.PP
yaidspcap_parse_pcap_headers_transport (yaidsPcapPacket_ptr packet,
ipHeader_ptr ipHeader)
.PP
\ 
.PP
char *\ 
.PP
yaidspcap_parse_pcap_headers_get_nettype (etherHeader_ptr etherHeader)
.PP
\ 
.PP
char *\ 
.PP
yaidspcap_parse_pcap_headers_get_transporttype (ipHeader_ptr ipHeader)
.PP
\ 
.PP
void\ 
.PP
yaidspcap_parse_pcap_headers_results (yaidsPcapPacketHeader_ptr
parsedPacketHeaders, yaidsPcapPacketHeaderFrame_ptr frameHeader,
yaidsPcapPacketHeaderNet_ptr netHeader,
yaidsPcapPacketHeaderTransport_ptr transportHeader)
.PP
\ 
.PP
void\ 
.PP
yaidspcap_parse_pcap_headers (yaidsPcapPacket_ptr packet,
yaidsPcapPacketHeader_ptr parsedPacketHeaders)
.PP
\ 
.PP
FILE *\ 
.PP
yaidspcap_open_output_pcap_file (yaidsPcapHandle_ptr pcapHandle,
yaidsConfig_ptr config)
.PP
\ 
.PP
void\ 
.PP
yaidspcap_write_packet (FILE *pcapFileHandle, yaidsPcapPacket_ptr
packet)
.PP
\ 
.PP
void\ 
.PP
yaidspcap_flush_output (FILE *pcapFileHandle)
.PP
\ 
.PP
void\ 
.PP
yaidspcap_finish (void)
.PP
\ 
.SS Macro Definition Documentation
.PP
.SS \[u25C6]\ ETH_HEADER_SIZE
#define ETH_HEADER_SIZE\ \ \ 14
.SS Function Documentation
.PP
.SS \[u25C6]\ yaidspcap_create_handle()
int yaidspcap_create_handle
(
yaidsConfig_ptr\ 
config,
yaidsPcapHandle_ptr\ 
pcapHandle\ 
)
.PP
.SS \[u25C6]\ yaidspcap_finish()
void yaidspcap_finish
(
void\ 
)
.PP
.SS \[u25C6]\ yaidspcap_flush_output()
void yaidspcap_flush_output
(
FILE *\ 
pcapFileHandle
)
.PP
.SS \[u25C6]\ yaidspcap_init()
void yaidspcap_init
(
yaidsPcapHandle_ptr\ 
pcapHandle
)
.PP
.SS \[u25C6]\ yaidspcap_new_packet()
yaidsPcapPacket_ptr yaidspcap_new_packet
(
int\ 
size
)
.PP
.SS \[u25C6]\ yaidspcap_open_output_pcap_file()
FILE* yaidspcap_open_output_pcap_file
(
yaidsPcapHandle_ptr\ 
pcapHandle,
yaidsConfig_ptr\ 
config\ 
)
.PP
.SS \[u25C6]\ yaidspcap_parse_pcap_headers()
void yaidspcap_parse_pcap_headers
(
yaidsPcapPacket_ptr\ 
packet,
yaidsPcapPacketHeader_ptr\ 
parsedPacketHeaders\ 
)
.PP
.SS \[u25C6]\ yaidspcap_parse_pcap_headers_frame()
yaidsPcapPacketHeaderFrame_ptr yaidspcap_parse_pcap_headers_frame
(
etherHeader_ptr\ 
etherHeader
)
.PP
.SS \[u25C6]\ yaidspcap_parse_pcap_headers_get_nettype()
char* yaidspcap_parse_pcap_headers_get_nettype
(
etherHeader_ptr\ 
etherHeader
)
.PP
.SS \[u25C6]\ yaidspcap_parse_pcap_headers_get_transporttype()
char* yaidspcap_parse_pcap_headers_get_transporttype
(
ipHeader_ptr\ 
ipHeader
)
.PP
.SS \[u25C6]\ yaidspcap_parse_pcap_headers_net()
yaidsPcapPacketHeaderNet_ptr yaidspcap_parse_pcap_headers_net
(
etherHeader_ptr\ 
etherHeader,
ipHeader_ptr\ 
ipHeader\ 
)
.PP
.SS \[u25C6]\ yaidspcap_parse_pcap_headers_results()
void yaidspcap_parse_pcap_headers_results
(
yaidsPcapPacketHeader_ptr\ 
parsedPacketHeaders,
yaidsPcapPacketHeaderFrame_ptr\ 
frameHeader,
yaidsPcapPacketHeaderNet_ptr\ 
netHeader,
yaidsPcapPacketHeaderTransport_ptr\ 
transportHeader\ 
)
.PP
.SS \[u25C6]\ yaidspcap_parse_pcap_headers_transport()
yaidsPcapPacketHeaderTransport_ptr
yaidspcap_parse_pcap_headers_transport
(
yaidsPcapPacket_ptr\ 
packet,
ipHeader_ptr\ 
ipHeader\ 
)
.PP
.SS \[u25C6]\ yaidspcap_read_callback()
void yaidspcap_read_callback
(
u_char *\ 
args,
const struct pcap_pkthdr *\ 
packetHeader,
const u_char *\ 
packetBody\ 
)
.PP
.SS \[u25C6]\ yaidspcap_read_packets()
void yaidspcap_read_packets
(
yaidsPcapHandle_ptr\ 
pcapHandle,
yaidsPcapCallbackArgs_ptr\ 
callbackArgs\ 
)
.PP
.SS \[u25C6]\ yaidspcap_write_packet()
void yaidspcap_write_packet
(
FILE *\ 
pcapFileHandle,
yaidsPcapPacket_ptr\ 
packet\ 
)
.PP
   *   *   *   *   *
.PP
Source Code Documentation Generated By \f[C]doxygen\f[R] \ 
.SH yaidsthread
.PP
YAIDS
.PP
Macros | Functions | Variables
.PP
yaidsthread.h File Reference
.SS  Macros
.PP
#define\ 
.PP
YAIDS_THREAD_INPUT_PCAP\ \ \ 1
.PP
\ 
.PP
#define\ 
.PP
YAIDS_THREAD_OUTPUT\ \ \ 2
.PP
\ 
.PP
#define\ 
.PP
YAIDS_THREAD_YARA\ \ \ 3
.PP
\ 
.PP
#define\ 
.PP
YAIDS_THREAD_TIMELIMIT\ \ \ 4
.PP
\ 
.PP
#define\ 
.PP
MAX_OUTPUT_ELEMENT_SIZE\ \ \ 60
.PP
\ 
.PP
#define\ 
.PP
MAX_OUTPUT_SINGLE_SIZE\ \ \ 20
.PP
\ 
.SS  Functions
.PP
yaidsPacketCounts_ptr\ 
.PP
yaidsthread_new_packet_counts (void)
.PP
\ 
.PP
yaidsThreadStatuses_ptr\ 
.PP
yaidsthread_new_thread_statuses (void)
.PP
\ 
.PP
yaidsInputDataQueue_ptr\ 
.PP
yaidsthread_new_input_queue (void)
.PP
\ 
.PP
yaidsInputDataNode_ptr\ 
.PP
yaidsthread_new_input_data (yaidsPcapPacket_ptr packet)
.PP
\ 
.PP
yaidsInputThreadArgs_ptr\ 
.PP
yaidsthread_new_input_thread_args (yaidsInputDataQueue_ptr dataQueue,
yaidsPcapHandle_ptr pcapHandle, yaidsConfig_ptr config,
yaidsPacketCounts_ptr packetCounts, yaidsThreadStatuses_ptr
threadStatuses)
.PP
\ 
.PP
yaidsTimelimitThreadArgs_ptr\ 
.PP
yaidsthread_new_timelimit_thread_args (bool *yaidsRunning,
yaidsConfig_ptr config)
.PP
\ 
.PP
yaidsOutputDataQueue_ptr\ 
.PP
yaidsthread_new_output_queue (void)
.PP
\ 
.PP
yaidsOutputDataNode_ptr\ 
.PP
yaidsthread_new_output_data (yaidsPcapPacket_ptr packet, char *alert)
.PP
\ 
.PP
yaidsOutputThreadArgs_ptr\ 
.PP
yaidsthread_new_output_thread_args (yaidsOutputDataQueue_ptr dataQueue,
yaidsPcapHandle_ptr pcapHandle, yaidsConfig_ptr config,
yaidsPacketCounts_ptr packetCounts, yaidsThreadStatuses_ptr
threadStatuses)
.PP
\ 
.PP
yaidsYaraThreadArgs_ptr\ 
.PP
yaidsthread_new_yara_thread_args (yaidsInputDataQueue_ptr
inputDataQueue, yaidsOutputDataQueue_ptr outputDataQueue,
yaidsYaraScanner_ptr yaraScanner, yaidsConfig_ptr config,
yaidsPacketCounts_ptr packetCounts, yaidsThreadStatuses_ptr
threadStatuses)
.PP
\ 
.PP
void\ 
.PP
yaidsthread_update_pcap_packet_count (yaidsPacketCounts_ptr
packetCounts)
.PP
\ 
.PP
void\ 
.PP
yaidsthread_update_yara_packet_count (yaidsPacketCounts_ptr
packetCounts)
.PP
\ 
.PP
void\ 
.PP
yaidsthread_update_alert_packet_count (yaidsPacketCounts_ptr
packetCounts)
.PP
\ 
.PP
void\ 
.PP
yaidsthread_update_output_packet_count (yaidsPacketCounts_ptr
packetCounts)
.PP
\ 
.PP
void\ 
.PP
yaidsthread_set_pcap_finished (yaidsThreadStatuses_ptr threadStatuses,
yaidsConfig_ptr config)
.PP
\ 
.PP
void\ 
.PP
yaidsthread_set_yara_finished (yaidsThreadStatuses_ptr threadStatuses,
yaidsConfig_ptr config)
.PP
\ 
.PP
void\ 
.PP
yaidsthread_set_output_finished (yaidsThreadStatuses_ptr threadStatuses,
yaidsConfig_ptr config)
.PP
\ 
.PP
void\ 
.PP
yaidsthread_add_input_data (yaidsInputDataQueue_ptr dataQueue,
yaidsPcapPacket_ptr packet)
.PP
\ 
.PP
yaidsInputDataNode\ 
.PP
yaidsthread_get_input_data (yaidsInputDataQueue_ptr dataQueue)
.PP
\ 
.PP
void\ 
.PP
yaidsthread_add_output_data (yaidsOutputDataQueue_ptr dataQueue,
yaidsPcapPacket_ptr packet, char *alert)
.PP
\ 
.PP
yaidsOutputDataNode\ 
.PP
yaidsthread_get_output_data (yaidsOutputDataQueue_ptr dataQueue)
.PP
\ 
.PP
yaidsThreadReturn\ 
.PP
yaidsthread_create_pcap_thread (yaidsInputThreadArgs_ptr threadArgs)
.PP
\ 
.PP
yaidsThreadReturn\ 
.PP
yaidsthread_create_yara_thread (yaidsYaraThreadArgs_ptr threadArgs)
.PP
\ 
.PP
yaidsThreadReturn\ 
.PP
yaidsthread_create_output_thread (yaidsOutputThreadArgs_ptr threadArgs)
.PP
\ 
.PP
yaidsThreadReturn\ 
.PP
yaidsthread_create_timelimit_thread (yaidsTimelimitThreadArgs_ptr
threadArgs)
.PP
\ 
.PP
yaidsThreadList_ptr\ 
.PP
yaidsthread_new_threadlist (yaidsConfig_ptr config)
.PP
\ 
.PP
yaidsThreadInfo_ptr\ 
.PP
yaidsthread_new_threadinfo (void)
.PP
\ 
.PP
int\ 
.PP
yaidsthread_start_input_threads (yaidsConfig_ptr config,
yaidsThreadList_ptr threadList, yaidsThreadStatuses_ptr threadStatuses,
yaidsPcapHandle_ptr pcapHandle, yaidsInputDataQueue_ptr yaidsInputQueue,
yaidsPacketCounts_ptr packetCounts)
.PP
\ 
.PP
int\ 
.PP
yaidsthread_start_yara_threads (yaidsConfig_ptr config,
yaidsThreadList_ptr threadList, yaidsThreadStatuses_ptr threadStatuses,
yaidsInputDataQueue_ptr yaidsInputQueue, yaidsOutputDataQueue_ptr
yaidsOutputQueue, yaidsYaraScanner_ptr yaraScanners,
yaidsPacketCounts_ptr packetCounts)
.PP
\ 
.PP
int\ 
.PP
yaidsthread_start_output_threads (yaidsConfig_ptr config,
yaidsThreadList_ptr threadList, yaidsThreadStatuses_ptr threadStatuses,
yaidsPcapHandle_ptr pcapHandle, yaidsOutputDataQueue_ptr
yaidsOutputQueue, yaidsPacketCounts_ptr packetCounts, int
scannerThreadCount)
.PP
\ 
.PP
int\ 
.PP
yaidsthread_start_timelimit_threads (yaidsConfig_ptr config,
yaidsThreadList_ptr threadList, bool *yaidsRunning, int
scannerThreadCount)
.PP
\ 
.PP
int\ 
.PP
yaidsthread_run_threads (bool *yaidsRunning, yaidsConfig config,
yaidsThreadList_ptr threadList, yaidsInputDataQueue_ptr yaidsInputQueue,
yaidsOutputDataQueue_ptr yaidsOutputQueue, yaidsPcapHandle_ptr
pcapHandle, yaidsYaraScanner_ptr yaraScanners)
.PP
\ 
.PP
void *\ 
.PP
yaidsthread_pcap_thread (void *args)
.PP
\ 
.PP
void *\ 
.PP
yaidsthread_yara_thread (void *args)
.PP
\ 
.PP
void *\ 
.PP
yaidsthread_output_thread (void *args)
.PP
\ 
.PP
void *\ 
.PP
yaidsthread_timelimit_thread (void *args)
.PP
\ 
.SS  Variables
.PP
static pthread_mutex_t\ 
.PP
dataInputQueueMutex = PTHREAD_MUTEX_INITIALIZER
.PP
\ 
.PP
static pthread_mutex_t\ 
.PP
dataInputQueueNextMutex = PTHREAD_MUTEX_INITIALIZER
.PP
\ 
.PP
static pthread_mutex_t\ 
.PP
dataInputQueueReadMutex = PTHREAD_MUTEX_INITIALIZER
.PP
\ 
.PP
static pthread_mutex_t\ 
.PP
dataOutputQueueMutex = PTHREAD_MUTEX_INITIALIZER
.PP
\ 
.PP
static pthread_mutex_t\ 
.PP
dataOutputQueueNextMutex
.PP
\ 
.PP
static pthread_mutex_t\ 
.PP
dataOutputQueueReadMutex
.PP
\ 
.PP
static pthread_mutex_t\ 
.PP
packetCountsandThreadStatusesMutex = PTHREAD_MUTEX_INITIALIZER
.PP
\ 
.PP
static pthread_mutex_t\ 
.PP
packetCountsandThreadStatusesNextMutex
.PP
\ 
.PP
static pthread_mutex_t\ 
.PP
packetCountsandThreadStatusesLowMutex
.PP
\ 
.SS Macro Definition Documentation
.PP
.SS \[u25C6]\ MAX_OUTPUT_ELEMENT_SIZE
#define MAX_OUTPUT_ELEMENT_SIZE\ \ \ 60
.PP
.SS \[u25C6]\ MAX_OUTPUT_SINGLE_SIZE
#define MAX_OUTPUT_SINGLE_SIZE\ \ \ 20
.PP
.SS \[u25C6]\ YAIDS_THREAD_INPUT_PCAP
#define YAIDS_THREAD_INPUT_PCAP\ \ \ 1
.PP
.SS \[u25C6]\ YAIDS_THREAD_OUTPUT
#define YAIDS_THREAD_OUTPUT\ \ \ 2
.PP
.SS \[u25C6]\ YAIDS_THREAD_TIMELIMIT
#define YAIDS_THREAD_TIMELIMIT\ \ \ 4
.PP
.SS \[u25C6]\ YAIDS_THREAD_YARA
#define YAIDS_THREAD_YARA\ \ \ 3
.SS Function Documentation
.PP
.SS \[u25C6]\ yaidsthread_add_input_data()
void yaidsthread_add_input_data
(
yaidsInputDataQueue_ptr\ 
dataQueue,
yaidsPcapPacket_ptr\ 
packet\ 
)
.PP
.SS \[u25C6]\ yaidsthread_add_output_data()
void yaidsthread_add_output_data
(
yaidsOutputDataQueue_ptr\ 
dataQueue,
yaidsPcapPacket_ptr\ 
packet,
char *\ 
alert\ 
)
.PP
.SS \[u25C6]\ yaidsthread_create_output_thread()
yaidsThreadReturn yaidsthread_create_output_thread
(
yaidsOutputThreadArgs_ptr\ 
threadArgs
)
.PP
.SS \[u25C6]\ yaidsthread_create_pcap_thread()
yaidsThreadReturn yaidsthread_create_pcap_thread
(
yaidsInputThreadArgs_ptr\ 
threadArgs
)
.PP
.SS \[u25C6]\ yaidsthread_create_timelimit_thread()
yaidsThreadReturn yaidsthread_create_timelimit_thread
(
yaidsTimelimitThreadArgs_ptr\ 
threadArgs
)
.PP
.SS \[u25C6]\ yaidsthread_create_yara_thread()
yaidsThreadReturn yaidsthread_create_yara_thread
(
yaidsYaraThreadArgs_ptr\ 
threadArgs
)
.PP
.SS \[u25C6]\ yaidsthread_get_input_data()
yaidsInputDataNode yaidsthread_get_input_data
(
yaidsInputDataQueue_ptr\ 
dataQueue
)
.PP
.SS \[u25C6]\ yaidsthread_get_output_data()
yaidsOutputDataNode yaidsthread_get_output_data
(
yaidsOutputDataQueue_ptr\ 
dataQueue
)
.PP
.SS \[u25C6]\ yaidsthread_new_input_data()
yaidsInputDataNode_ptr yaidsthread_new_input_data
(
yaidsPcapPacket_ptr\ 
packet
)
.PP
.SS \[u25C6]\ yaidsthread_new_input_queue()
yaidsInputDataQueue_ptr yaidsthread_new_input_queue
(
void\ 
)
.PP
.SS \[u25C6]\ yaidsthread_new_input_thread_args()
yaidsInputThreadArgs_ptr yaidsthread_new_input_thread_args
(
yaidsInputDataQueue_ptr\ 
dataQueue,
yaidsPcapHandle_ptr\ 
pcapHandle,
yaidsConfig_ptr\ 
config,
yaidsPacketCounts_ptr\ 
packetCounts,
yaidsThreadStatuses_ptr\ 
threadStatuses\ 
)
.PP
.SS \[u25C6]\ yaidsthread_new_output_data()
yaidsOutputDataNode_ptr yaidsthread_new_output_data
(
yaidsPcapPacket_ptr\ 
packet,
char *\ 
alert\ 
)
.PP
.SS \[u25C6]\ yaidsthread_new_output_queue()
yaidsOutputDataQueue_ptr yaidsthread_new_output_queue
(
void\ 
)
.PP
.SS \[u25C6]\ yaidsthread_new_output_thread_args()
yaidsOutputThreadArgs_ptr yaidsthread_new_output_thread_args
(
yaidsOutputDataQueue_ptr\ 
dataQueue,
yaidsPcapHandle_ptr\ 
pcapHandle,
yaidsConfig_ptr\ 
config,
yaidsPacketCounts_ptr\ 
packetCounts,
yaidsThreadStatuses_ptr\ 
threadStatuses\ 
)
.PP
.SS \[u25C6]\ yaidsthread_new_packet_counts()
yaidsPacketCounts_ptr yaidsthread_new_packet_counts
(
void\ 
)
.PP
.SS \[u25C6]\ yaidsthread_new_thread_statuses()
yaidsThreadStatuses_ptr yaidsthread_new_thread_statuses
(
void\ 
)
.PP
.SS \[u25C6]\ yaidsthread_new_threadinfo()
yaidsThreadInfo_ptr yaidsthread_new_threadinfo
(
void\ 
)
.PP
.SS \[u25C6]\ yaidsthread_new_threadlist()
yaidsThreadList_ptr yaidsthread_new_threadlist
(
yaidsConfig_ptr\ 
config
)
.PP
.SS \[u25C6]\ yaidsthread_new_timelimit_thread_args()
yaidsTimelimitThreadArgs_ptr yaidsthread_new_timelimit_thread_args
(
bool *\ 
yaidsRunning,
yaidsConfig_ptr\ 
config\ 
)
.PP
.SS \[u25C6]\ yaidsthread_new_yara_thread_args()
yaidsYaraThreadArgs_ptr yaidsthread_new_yara_thread_args
(
yaidsInputDataQueue_ptr\ 
inputDataQueue,
yaidsOutputDataQueue_ptr\ 
outputDataQueue,
yaidsYaraScanner_ptr\ 
yaraScanner,
yaidsConfig_ptr\ 
config,
yaidsPacketCounts_ptr\ 
packetCounts,
yaidsThreadStatuses_ptr\ 
threadStatuses\ 
)
.PP
.SS \[u25C6]\ yaidsthread_output_thread()
void* yaidsthread_output_thread
(
void *\ 
args
)
.PP
.SS \[u25C6]\ yaidsthread_pcap_thread()
void* yaidsthread_pcap_thread
(
void *\ 
args
)
.PP
.SS \[u25C6]\ yaidsthread_run_threads()
int yaidsthread_run_threads
(
bool *\ 
yaidsRunning,
yaidsConfig\ 
config,
yaidsThreadList_ptr\ 
threadList,
yaidsInputDataQueue_ptr\ 
yaidsInputQueue,
yaidsOutputDataQueue_ptr\ 
yaidsOutputQueue,
yaidsPcapHandle_ptr\ 
pcapHandle,
yaidsYaraScanner_ptr\ 
yaraScanners\ 
)
.PP
.SS \[u25C6]\ yaidsthread_set_output_finished()
void yaidsthread_set_output_finished
(
yaidsThreadStatuses_ptr\ 
threadStatuses,
yaidsConfig_ptr\ 
config\ 
)
.PP
.SS \[u25C6]\ yaidsthread_set_pcap_finished()
void yaidsthread_set_pcap_finished
(
yaidsThreadStatuses_ptr\ 
threadStatuses,
yaidsConfig_ptr\ 
config\ 
)
.PP
.SS \[u25C6]\ yaidsthread_set_yara_finished()
void yaidsthread_set_yara_finished
(
yaidsThreadStatuses_ptr\ 
threadStatuses,
yaidsConfig_ptr\ 
config\ 
)
.PP
.SS \[u25C6]\ yaidsthread_start_input_threads()
int yaidsthread_start_input_threads
(
yaidsConfig_ptr\ 
config,
yaidsThreadList_ptr\ 
threadList,
yaidsThreadStatuses_ptr\ 
threadStatuses,
yaidsPcapHandle_ptr\ 
pcapHandle,
yaidsInputDataQueue_ptr\ 
yaidsInputQueue,
yaidsPacketCounts_ptr\ 
packetCounts\ 
)
.PP
.SS \[u25C6]\ yaidsthread_start_output_threads()
int yaidsthread_start_output_threads
(
yaidsConfig_ptr\ 
config,
yaidsThreadList_ptr\ 
threadList,
yaidsThreadStatuses_ptr\ 
threadStatuses,
yaidsPcapHandle_ptr\ 
pcapHandle,
yaidsOutputDataQueue_ptr\ 
yaidsOutputQueue,
yaidsPacketCounts_ptr\ 
packetCounts,
int\ 
scannerThreadCount\ 
)
.PP
.SS \[u25C6]\ yaidsthread_start_timelimit_threads()
int yaidsthread_start_timelimit_threads
(
yaidsConfig_ptr\ 
config,
yaidsThreadList_ptr\ 
threadList,
bool *\ 
yaidsRunning,
int\ 
scannerThreadCount\ 
)
.PP
.SS \[u25C6]\ yaidsthread_start_yara_threads()
int yaidsthread_start_yara_threads
(
yaidsConfig_ptr\ 
config,
yaidsThreadList_ptr\ 
threadList,
yaidsThreadStatuses_ptr\ 
threadStatuses,
yaidsInputDataQueue_ptr\ 
yaidsInputQueue,
yaidsOutputDataQueue_ptr\ 
yaidsOutputQueue,
yaidsYaraScanner_ptr\ 
yaraScanners,
yaidsPacketCounts_ptr\ 
packetCounts\ 
)
.PP
.SS \[u25C6]\ yaidsthread_timelimit_thread()
void* yaidsthread_timelimit_thread
(
void *\ 
args
)
.PP
.SS \[u25C6]\ yaidsthread_update_alert_packet_count()
void yaidsthread_update_alert_packet_count
(
yaidsPacketCounts_ptr\ 
packetCounts
)
.PP
.SS \[u25C6]\ yaidsthread_update_output_packet_count()
void yaidsthread_update_output_packet_count
(
yaidsPacketCounts_ptr\ 
packetCounts
)
.PP
.SS \[u25C6]\ yaidsthread_update_pcap_packet_count()
void yaidsthread_update_pcap_packet_count
(
yaidsPacketCounts_ptr\ 
packetCounts
)
.PP
.SS \[u25C6]\ yaidsthread_update_yara_packet_count()
void yaidsthread_update_yara_packet_count
(
yaidsPacketCounts_ptr\ 
packetCounts
)
.PP
.SS \[u25C6]\ yaidsthread_yara_thread()
void* yaidsthread_yara_thread
(
void *\ 
args
)
.SS Variable Documentation
.PP
.SS \[u25C6]\ dataInputQueueMutex
pthread_mutex_t dataInputQueueMutex = PTHREAD_MUTEX_INITIALIZER
static
.PP
.SS \[u25C6]\ dataInputQueueNextMutex
pthread_mutex_t dataInputQueueNextMutex = PTHREAD_MUTEX_INITIALIZER
static
.PP
.SS \[u25C6]\ dataInputQueueReadMutex
pthread_mutex_t dataInputQueueReadMutex = PTHREAD_MUTEX_INITIALIZER
static
.PP
.SS \[u25C6]\ dataOutputQueueMutex
pthread_mutex_t dataOutputQueueMutex = PTHREAD_MUTEX_INITIALIZER
static
.PP
.SS \[u25C6]\ dataOutputQueueNextMutex
pthread_mutex_t dataOutputQueueNextMutex
static
.PP
\f[B]Initial value:\f[R]
.PP
=
.PP
PTHREAD_MUTEX_INITIALIZER
.PP
.SS \[u25C6]\ dataOutputQueueReadMutex
pthread_mutex_t dataOutputQueueReadMutex
static
.PP
\f[B]Initial value:\f[R]
.PP
=
.PP
PTHREAD_MUTEX_INITIALIZER
.PP
.SS \[u25C6]\ packetCountsandThreadStatusesLowMutex
pthread_mutex_t packetCountsandThreadStatusesLowMutex
static
.PP
\f[B]Initial value:\f[R]
.PP
=
.PP
PTHREAD_MUTEX_INITIALIZER
.PP
.SS \[u25C6]\ packetCountsandThreadStatusesMutex
pthread_mutex_t packetCountsandThreadStatusesMutex =
PTHREAD_MUTEX_INITIALIZER
static
.PP
.SS \[u25C6]\ packetCountsandThreadStatusesNextMutex
pthread_mutex_t packetCountsandThreadStatusesNextMutex
static
.PP
\f[B]Initial value:\f[R]
.PP
=
.PP
PTHREAD_MUTEX_INITIALIZER
.PP
   *   *   *   *   *
.PP
Source Code Documentation Generated By \f[C]doxygen\f[R] \ 
.SH yaidstypes
.PP
YAIDS
.PP
Classes | Typedefs
.PP
yaidstypes.h File Reference
.PP
\f[C]#include <ctype.h>\f[R]
.PD 0
.P
.PD
\f[C]#include <stdio.h>\f[R]
.PD 0
.P
.PD
\f[C]#include <stdlib.h>\f[R]
.PD 0
.P
.PD
\f[C]#include <unistd.h>\f[R]
.PD 0
.P
.PD
\f[C]#include <stdbool.h>\f[R]
.PD 0
.P
.PD
\f[C]#include <pcap.h>\f[R]
.PD 0
.P
.PD
\f[C]#include <yara.h>\f[R]
.PD 0
.P
.PD
\f[C]#include <netinet/in.h>\f[R]
.PP
Include dependency graph for yaidstypes.h:
.PP

.SS  Classes
.PP
struct \ 
.PP
yaidsConfig_struct
.PP
\ 
.PP
struct \ 
.PP
yaidsThreadStatuses_struct
.PP
\ 
.PP
struct \ 
.PP
yaidsPacketCounts_struct
.PP
\ 
.PP
struct \ 
.PP
yaidsPcapHandle_struct
.PP
\ 
.PP
struct \ 
.PP
yaidsYaraScanner_struct
.PP
\ 
.PP
struct \ 
.PP
yaidsThreadReturn_struct
.PP
\ 
.PP
struct \ 
.PP
yaidsThreadInfo_struct
.PP
\ 
.PP
struct \ 
.PP
yaidsThreadList_struct
.PP
\ 
.PP
struct \ 
.PP
yaidsInputDataNode_struct
.PP
\ 
.PP
struct \ 
.PP
yaidsInputDataQueue_struct
.PP
\ 
.PP
struct \ 
.PP
yaidsInputThreadArgs_struct
.PP
\ 
.PP
struct \ 
.PP
yaidsOutputDataNode_struct
.PP
\ 
.PP
struct \ 
.PP
yaidsOutputDataQueue_struct
.PP
\ 
.PP
struct \ 
.PP
yaidsOutputThreadArgs_struct
.PP
\ 
.PP
struct \ 
.PP
yaidsYaraThreadArgs_struct
.PP
\ 
.PP
struct \ 
.PP
yaidsPcapCallbackArgs_struct
.PP
\ 
.PP
struct \ 
.PP
yaidsYaraCallbackArgs_struct
.PP
\ 
.PP
struct \ 
.PP
yaidsTimelimitThreadArgs_struct
.PP
\ 
.PP
struct \ 
.PP
yaidsPcapPacket_struct
.PP
\ 
.PP
struct \ 
.PP
yaidsPcapPacketHeader_struct
.PP
\ 
.PP
struct \ 
.PP
yaidsPcapPacketHeaderFrame_struct
.PP
\ 
.PP
struct \ 
.PP
yaidsPcapPacketHeaderNet_struct
.PP
\ 
.PP
struct \ 
.PP
yaidsPcapPacketHeaderTransport_struct
.PP
\ 
.SS  Typedefs
.PP
typedef struct yaidsConfig_struct\ 
.PP
yaidsConfig
.PP
\ 
.PP
typedef struct yaidsInputDataNode_struct\ 
.PP
yaidsInputDataNode
.PP
\ 
.PP
typedef struct yaidsInputDataQueue_struct\ 
.PP
yaidsInputDataQueue
.PP
\ 
.PP
typedef struct yaidsInputThreadArgs_struct\ 
.PP
yaidsInputThreadArgs
.PP
\ 
.PP
typedef struct yaidsOutputDataNode_struct\ 
.PP
yaidsOutputDataNode
.PP
\ 
.PP
typedef struct yaidsOutputDataQueue_struct\ 
.PP
yaidsOutputDataQueue
.PP
\ 
.PP
typedef struct yaidsOutputThreadArgs_struct\ 
.PP
yaidsOutputThreadArgs
.PP
\ 
.PP
typedef struct yaidsPacketCounts_struct\ 
.PP
yaidsPacketCounts
.PP
\ 
.PP
typedef struct yaidsPcapCallbackArgs_struct\ 
.PP
yaidsPcapCallbackArgs
.PP
\ 
.PP
typedef struct yaidsPcapHandle_struct\ 
.PP
yaidsPcapHandle
.PP
\ 
.PP
typedef struct yaidsPcapPacket_struct\ 
.PP
yaidsPcapPacket
.PP
\ 
.PP
typedef struct yaidsPcapPacketHeader_struct\ 
.PP
yaidsPcapPacketHeader
.PP
\ 
.PP
typedef struct yaidsPcapPacketHeaderFrame_struct\ 
.PP
yaidsPcapPacketHeaderFrame
.PP
\ 
.PP
typedef struct yaidsPcapPacketHeaderNet_struct\ 
.PP
yaidsPcapPacketHeaderNet
.PP
\ 
.PP
typedef struct yaidsPcapPacketHeaderTransport_struct\ 
.PP
yaidsPcapPacketHeaderTransport
.PP
\ 
.PP
typedef struct yaidsThreadInfo_struct\ 
.PP
yaidsThreadInfo
.PP
\ 
.PP
typedef struct yaidsThreadList_struct\ 
.PP
yaidsThreadList
.PP
\ 
.PP
typedef struct yaidsThreadReturn_struct\ 
.PP
yaidsThreadReturn
.PP
\ 
.PP
typedef struct yaidsThreadStatuses_struct\ 
.PP
yaidsThreadStatuses
.PP
\ 
.PP
typedef struct yaidsTimelimitThreadArgs_struct\ 
.PP
yaidsTimelimitThreadArgs
.PP
\ 
.PP
typedef struct yaidsYaraCallbackArgs_struct\ 
.PP
yaidsYaraCallbackArgs
.PP
\ 
.PP
typedef struct yaidsYaraScanner_struct\ 
.PP
yaidsYaraScanner
.PP
\ 
.PP
typedef struct yaidsYaraThreadArgs_struct\ 
.PP
yaidsYaraThreadArgs
.PP
\ 
.PP
typedef yaidsConfig *\ 
.PP
yaidsConfig_ptr
.PP
\ 
.PP
typedef yaidsInputDataNode *\ 
.PP
yaidsInputDataNode_ptr
.PP
\ 
.PP
typedef yaidsInputDataQueue *\ 
.PP
yaidsInputDataQueue_ptr
.PP
\ 
.PP
typedef yaidsInputThreadArgs *\ 
.PP
yaidsInputThreadArgs_ptr
.PP
\ 
.PP
typedef yaidsOutputDataNode *\ 
.PP
yaidsOutputDataNode_ptr
.PP
\ 
.PP
typedef yaidsOutputDataQueue *\ 
.PP
yaidsOutputDataQueue_ptr
.PP
\ 
.PP
typedef yaidsOutputThreadArgs *\ 
.PP
yaidsOutputThreadArgs_ptr
.PP
\ 
.PP
typedef yaidsPacketCounts *\ 
.PP
yaidsPacketCounts_ptr
.PP
\ 
.PP
typedef yaidsPcapCallbackArgs *\ 
.PP
yaidsPcapCallbackArgs_ptr
.PP
\ 
.PP
typedef yaidsPcapHandle *\ 
.PP
yaidsPcapHandle_ptr
.PP
\ 
.PP
typedef yaidsPcapPacket *\ 
.PP
yaidsPcapPacket_ptr
.PP
\ 
.PP
typedef yaidsPcapPacketHeader *\ 
.PP
yaidsPcapPacketHeader_ptr
.PP
\ 
.PP
typedef yaidsPcapPacketHeaderFrame *\ 
.PP
yaidsPcapPacketHeaderFrame_ptr
.PP
\ 
.PP
typedef yaidsPcapPacketHeaderNet *\ 
.PP
yaidsPcapPacketHeaderNet_ptr
.PP
\ 
.PP
typedef yaidsPcapPacketHeaderTransport *\ 
.PP
yaidsPcapPacketHeaderTransport_ptr
.PP
\ 
.PP
typedef yaidsThreadInfo *\ 
.PP
yaidsThreadInfo_ptr
.PP
\ 
.PP
typedef yaidsThreadList *\ 
.PP
yaidsThreadList_ptr
.PP
\ 
.PP
typedef yaidsThreadReturn *\ 
.PP
yaidsThreadReturn_ptr
.PP
\ 
.PP
typedef yaidsThreadStatuses *\ 
.PP
yaidsThreadStatuses_ptr
.PP
\ 
.PP
typedef yaidsTimelimitThreadArgs *\ 
.PP
yaidsTimelimitThreadArgs_ptr
.PP
\ 
.PP
typedef yaidsYaraCallbackArgs *\ 
.PP
yaidsYaraCallbackArgs_ptr
.PP
\ 
.PP
typedef yaidsYaraScanner *\ 
.PP
yaidsYaraScanner_ptr
.PP
\ 
.PP
typedef yaidsYaraThreadArgs *\ 
.PP
yaidsYaraThreadArgs_ptr
.PP
\ 
.PP
typedef struct ether_header *\ 
.PP
etherHeader_ptr
.PP
\ 
.PP
typedef struct ip *\ 
.PP
ipHeader_ptr
.PP
\ 
.PP
typedef struct tcphdr *\ 
.PP
tcpHeader_ptr
.PP
\ 
.PP
typedef struct udphdr *\ 
.PP
udpHeader_ptr
.PP
\ 
.SS Typedef Documentation
.PP
.SS \[u25C6]\ etherHeader_ptr
typedef struct ether_header* etherHeader_ptr
.PP
.SS \[u25C6]\ ipHeader_ptr
typedef struct ip* ipHeader_ptr
.PP
.SS \[u25C6]\ tcpHeader_ptr
typedef struct tcphdr* tcpHeader_ptr
.PP
.SS \[u25C6]\ udpHeader_ptr
typedef struct udphdr* udpHeader_ptr
.PP
.SS \[u25C6]\ yaidsConfig
typedef struct yaidsConfig_struct yaidsConfig
.PP
.SS \[u25C6]\ yaidsConfig_ptr
typedef yaidsConfig* yaidsConfig_ptr
.PP
.SS \[u25C6]\ yaidsInputDataNode
typedef struct yaidsInputDataNode_struct yaidsInputDataNode
.PP
.SS \[u25C6]\ yaidsInputDataNode_ptr
typedef yaidsInputDataNode* yaidsInputDataNode_ptr
.PP
.SS \[u25C6]\ yaidsInputDataQueue
typedef struct yaidsInputDataQueue_struct yaidsInputDataQueue
.PP
.SS \[u25C6]\ yaidsInputDataQueue_ptr
typedef yaidsInputDataQueue* yaidsInputDataQueue_ptr
.PP
.SS \[u25C6]\ yaidsInputThreadArgs
typedef struct yaidsInputThreadArgs_struct yaidsInputThreadArgs
.PP
.SS \[u25C6]\ yaidsInputThreadArgs_ptr
typedef yaidsInputThreadArgs* yaidsInputThreadArgs_ptr
.PP
.SS \[u25C6]\ yaidsOutputDataNode
typedef struct yaidsOutputDataNode_struct yaidsOutputDataNode
.PP
.SS \[u25C6]\ yaidsOutputDataNode_ptr
typedef yaidsOutputDataNode* yaidsOutputDataNode_ptr
.PP
.SS \[u25C6]\ yaidsOutputDataQueue
typedef struct yaidsOutputDataQueue_struct yaidsOutputDataQueue
.PP
.SS \[u25C6]\ yaidsOutputDataQueue_ptr
typedef yaidsOutputDataQueue* yaidsOutputDataQueue_ptr
.PP
.SS \[u25C6]\ yaidsOutputThreadArgs
typedef struct yaidsOutputThreadArgs_struct yaidsOutputThreadArgs
.PP
.SS \[u25C6]\ yaidsOutputThreadArgs_ptr
typedef yaidsOutputThreadArgs* yaidsOutputThreadArgs_ptr
.PP
.SS \[u25C6]\ yaidsPacketCounts
typedef struct yaidsPacketCounts_struct yaidsPacketCounts
.PP
.SS \[u25C6]\ yaidsPacketCounts_ptr
typedef yaidsPacketCounts* yaidsPacketCounts_ptr
.PP
.SS \[u25C6]\ yaidsPcapCallbackArgs
typedef struct yaidsPcapCallbackArgs_struct yaidsPcapCallbackArgs
.PP
.SS \[u25C6]\ yaidsPcapCallbackArgs_ptr
typedef yaidsPcapCallbackArgs* yaidsPcapCallbackArgs_ptr
.PP
.SS \[u25C6]\ yaidsPcapHandle
typedef struct yaidsPcapHandle_struct yaidsPcapHandle
.PP
.SS \[u25C6]\ yaidsPcapHandle_ptr
typedef yaidsPcapHandle* yaidsPcapHandle_ptr
.PP
.SS \[u25C6]\ yaidsPcapPacket
typedef struct yaidsPcapPacket_struct yaidsPcapPacket
.PP
.SS \[u25C6]\ yaidsPcapPacket_ptr
typedef yaidsPcapPacket* yaidsPcapPacket_ptr
.PP
.SS \[u25C6]\ yaidsPcapPacketHeader
typedef struct yaidsPcapPacketHeader_struct yaidsPcapPacketHeader
.PP
.SS \[u25C6]\ yaidsPcapPacketHeader_ptr
typedef yaidsPcapPacketHeader* yaidsPcapPacketHeader_ptr
.PP
.SS \[u25C6]\ yaidsPcapPacketHeaderFrame
typedef struct yaidsPcapPacketHeaderFrame_struct
yaidsPcapPacketHeaderFrame
.PP
.SS \[u25C6]\ yaidsPcapPacketHeaderFrame_ptr
typedef yaidsPcapPacketHeaderFrame* yaidsPcapPacketHeaderFrame_ptr
.PP
.SS \[u25C6]\ yaidsPcapPacketHeaderNet
typedef struct yaidsPcapPacketHeaderNet_struct yaidsPcapPacketHeaderNet
.PP
.SS \[u25C6]\ yaidsPcapPacketHeaderNet_ptr
typedef yaidsPcapPacketHeaderNet* yaidsPcapPacketHeaderNet_ptr
.PP
.SS \[u25C6]\ yaidsPcapPacketHeaderTransport
typedef struct yaidsPcapPacketHeaderTransport_struct
yaidsPcapPacketHeaderTransport
.PP
.SS \[u25C6]\ yaidsPcapPacketHeaderTransport_ptr
typedef yaidsPcapPacketHeaderTransport*
yaidsPcapPacketHeaderTransport_ptr
.PP
.SS \[u25C6]\ yaidsThreadInfo
typedef struct yaidsThreadInfo_struct yaidsThreadInfo
.PP
.SS \[u25C6]\ yaidsThreadInfo_ptr
typedef yaidsThreadInfo* yaidsThreadInfo_ptr
.PP
.SS \[u25C6]\ yaidsThreadList
typedef struct yaidsThreadList_struct yaidsThreadList
.PP
.SS \[u25C6]\ yaidsThreadList_ptr
typedef yaidsThreadList* yaidsThreadList_ptr
.PP
.SS \[u25C6]\ yaidsThreadReturn
typedef struct yaidsThreadReturn_struct yaidsThreadReturn
.PP
.SS \[u25C6]\ yaidsThreadReturn_ptr
typedef yaidsThreadReturn* yaidsThreadReturn_ptr
.PP
.SS \[u25C6]\ yaidsThreadStatuses
typedef struct yaidsThreadStatuses_struct yaidsThreadStatuses
.PP
.SS \[u25C6]\ yaidsThreadStatuses_ptr
typedef yaidsThreadStatuses* yaidsThreadStatuses_ptr
.PP
.SS \[u25C6]\ yaidsTimelimitThreadArgs
typedef struct yaidsTimelimitThreadArgs_struct yaidsTimelimitThreadArgs
.PP
.SS \[u25C6]\ yaidsTimelimitThreadArgs_ptr
typedef yaidsTimelimitThreadArgs* yaidsTimelimitThreadArgs_ptr
.PP
.SS \[u25C6]\ yaidsYaraCallbackArgs
typedef struct yaidsYaraCallbackArgs_struct yaidsYaraCallbackArgs
.PP
.SS \[u25C6]\ yaidsYaraCallbackArgs_ptr
typedef yaidsYaraCallbackArgs* yaidsYaraCallbackArgs_ptr
.PP
.SS \[u25C6]\ yaidsYaraScanner
typedef struct yaidsYaraScanner_struct yaidsYaraScanner
.PP
.SS \[u25C6]\ yaidsYaraScanner_ptr
typedef yaidsYaraScanner* yaidsYaraScanner_ptr
.PP
.SS \[u25C6]\ yaidsYaraThreadArgs
typedef struct yaidsYaraThreadArgs_struct yaidsYaraThreadArgs
.PP
.SS \[u25C6]\ yaidsYaraThreadArgs_ptr
typedef yaidsYaraThreadArgs* yaidsYaraThreadArgs_ptr
.PP
   *   *   *   *   *
.PP
Source Code Documentation Generated By \f[C]doxygen\f[R] \ 
.SH yaidsyara
.PP
YAIDS
.PP
Functions
.PP
yaidsyara.h File Reference
.SS  Functions
.PP
int\ 
.PP
yaidsyara_yara_initialize (void)
.PP
\ 
.PP
int\ 
.PP
yaidsyara_yara_finalize (void)
.PP
\ 
.PP
void\ 
.PP
yaidsyara_init (yaidsYaraScanner_ptr yara)
.PP
\ 
.PP
int\ 
.PP
yaidsyara_create_scanner (yaidsConfig_ptr config, yaidsYaraScanner_ptr
yara)
.PP
\ 
.PP
int\ 
.PP
yaidsyara_create_scanners (yaidsConfig_ptr config, yaidsYaraScanner_ptr
yaraScanners)
.PP
\ 
.PP
void\ 
.PP
yaidsyara_scan_packet (yaidsYaraScanner_ptr yaraScanner,
yaidsPcapPacket_ptr packet, yaidsOutputDataQueue_ptr yaidsOutputQueue,
yaidsYaraCallbackArgs_ptr callbackArgs, yaidsConfig_ptr config)
.PP
\ 
.PP
int\ 
.PP
yaidsyara_scanner_callback (YR_SCAN_CONTEXT *scanContext, int status,
void *rule, void *args)
.PP
\ 
.PP
char *\ 
.PP
yaidsyara_scanner_callback_get_alert (yaidsYaraCallbackArgs_ptr
callbackArgs, YR_RULE *yaraRule, YR_SCAN_CONTEXT *scanContext)
.PP
\ 
.PP
void\ 
.PP
yaidsyara_scanner_callback_get_alert_line (yaidsYaraCallbackArgs_ptr
callbackArgs, yaidsPcapPacketHeader_ptr parsedPacketHeaders, char
*alertString, int alertStringMax, char *timeString, char *ruleName, char
*metaMatch, char *stringMatch)
.PP
\ 
.PP
char *\ 
.PP
yaidsyara_scanner_callback_get_match_meta (YR_SCAN_CONTEXT *scanContext,
YR_RULE *yaraRule)
.PP
\ 
.PP
char *\ 
.PP
yaidsyara_scanner_callback_get_match_string (YR_SCAN_CONTEXT
*scanContext, YR_RULE *yaraRule)
.PP
\ 
.SS Function Documentation
.PP
.SS \[u25C6]\ yaidsyara_create_scanner()
int yaidsyara_create_scanner
(
yaidsConfig_ptr\ 
config,
yaidsYaraScanner_ptr\ 
yara\ 
)
.PP
.SS \[u25C6]\ yaidsyara_create_scanners()
int yaidsyara_create_scanners
(
yaidsConfig_ptr\ 
config,
yaidsYaraScanner_ptr\ 
yaraScanners\ 
)
.PP
.SS \[u25C6]\ yaidsyara_init()
void yaidsyara_init
(
yaidsYaraScanner_ptr\ 
yara
)
.PP
.SS \[u25C6]\ yaidsyara_scan_packet()
void yaidsyara_scan_packet
(
yaidsYaraScanner_ptr\ 
yaraScanner,
yaidsPcapPacket_ptr\ 
packet,
yaidsOutputDataQueue_ptr\ 
yaidsOutputQueue,
yaidsYaraCallbackArgs_ptr\ 
callbackArgs,
yaidsConfig_ptr\ 
config\ 
)
.PP
.SS \[u25C6]\ yaidsyara_scanner_callback()
int yaidsyara_scanner_callback
(
YR_SCAN_CONTEXT *\ 
scanContext,
int\ 
status,
void *\ 
rule,
void *\ 
args\ 
)
.PP
.SS \[u25C6]\ yaidsyara_scanner_callback_get_alert()
char* yaidsyara_scanner_callback_get_alert
(
yaidsYaraCallbackArgs_ptr\ 
callbackArgs,
YR_RULE *\ 
yaraRule,
YR_SCAN_CONTEXT *\ 
scanContext\ 
)
.PP
.SS \[u25C6]\ yaidsyara_scanner_callback_get_alert_line()
void yaidsyara_scanner_callback_get_alert_line
(
yaidsYaraCallbackArgs_ptr\ 
callbackArgs,
yaidsPcapPacketHeader_ptr\ 
parsedPacketHeaders,
char *\ 
alertString,
int\ 
alertStringMax,
char *\ 
timeString,
char *\ 
ruleName,
char *\ 
metaMatch,
char *\ 
stringMatch\ 
)
.PP
.SS \[u25C6]\ yaidsyara_scanner_callback_get_match_meta()
char* yaidsyara_scanner_callback_get_match_meta
(
YR_SCAN_CONTEXT *\ 
scanContext,
YR_RULE *\ 
yaraRule\ 
)
.PP
.SS \[u25C6]\ yaidsyara_scanner_callback_get_match_string()
char* yaidsyara_scanner_callback_get_match_string
(
YR_SCAN_CONTEXT *\ 
scanContext,
YR_RULE *\ 
yaraRule\ 
)
.PP
.SS \[u25C6]\ yaidsyara_yara_finalize()
int yaidsyara_yara_finalize
(
void\ 
)
.PP
.SS \[u25C6]\ yaidsyara_yara_initialize()
int yaidsyara_yara_initialize
(
void\ 
)
.PP
   *   *   *   *   *
.PP
Source Code Documentation Generated By \f[C]doxygen\f[R] \ 
.SH yaids
.PP
YAIDS
.PP
Functions | Variables
.PP
yaids.c File Reference
.PP
\f[C]#include <config.h>\f[R]
.PD 0
.P
.PD
\f[C]#include <ctype.h>\f[R]
.PD 0
.P
.PD
\f[C]#include <stdio.h>\f[R]
.PD 0
.P
.PD
\f[C]#include <stdlib.h>\f[R]
.PD 0
.P
.PD
\f[C]#include <unistd.h>\f[R]
.PD 0
.P
.PD
\f[C]#include <stdbool.h>\f[R]
.PD 0
.P
.PD
\f[C]#include <yaids.h>\f[R]
.PD 0
.P
.PD
\f[C]#include <yaidstypes.h>\f[R]
.PD 0
.P
.PD
\f[C]#include <yaidsconf.h>\f[R]
.PD 0
.P
.PD
\f[C]#include <yaidsio.h>\f[R]
.PD 0
.P
.PD
\f[C]#include <yaidspcap.h>\f[R]
.PD 0
.P
.PD
\f[C]#include <yaidsyara.h>\f[R]
.PD 0
.P
.PD
\f[C]#include <yaidsthread.h>\f[R]
.PD 0
.P
.PD
\f[C]#include <yara.h>\f[R]
.PD 0
.P
.PD
\f[C]#include <signal.h>\f[R]
.PP
Include dependency graph for yaids.c:
.PP

.SS  Functions
.PP
void\ 
.PP
yaids_signal (int signalValue)
.PP
\ 
.PP
bool\ 
.PP
verify_status (int statusCode)
.PP
\ 
.PP
int\ 
.PP
main (int argc, char **argv)
.PP
\ 
.SS  Variables
.PP
const char *\ 
.PP
PROGRAM_NAME = \[lq]YAIDS\[rq]
.PP
\ 
.PP
const char *\ 
.PP
COPYRIGHT
.PP
\ 
.PP
const char *\ 
.PP
PROGRAM_SUBLINE
.PP
\ 
.PP
const char *\ 
.PP
PROGRAM_DESCRIPTION
.PP
\ 
.PP
const char *\ 
.PP
PROGRAM_VERSION = PACKAGE_VERSION
.PP
\ 
.PP
bool\ 
.PP
global_yaidsRunning = true
.PP
\ 
.SS Function Documentation
.PP
.SS \[u25C6]\ main()
int main
(
int\ 
argc,
char **\ 
argv\ 
)
.PP
.SS \[u25C6]\ verify_status()
bool verify_status
(
int\ 
statusCode
)
.PP
.SS \[u25C6]\ yaids_signal()
void yaids_signal
(
int\ 
signalValue
)
.SS Variable Documentation
.PP
.SS \[u25C6]\ COPYRIGHT
const char* COPYRIGHT
.PP
\f[B]Initial value:\f[R]
.PP
=
.PP
\[lq]COPYRIGHT (C) Justin M. Wray | Licensed: BSD 3\-Clause\[rq]
.PP
.SS \[u25C6]\ global_yaidsRunning
bool global_yaidsRunning = true
.PP
.SS \[u25C6]\ PROGRAM_DESCRIPTION
const char* PROGRAM_DESCRIPTION
.PP
\f[B]Initial value:\f[R]
.PP
=
.PP
\[lq]An Intrusion Detection System (IDS), utilizing Yara rules, and
multi\-threading\[rq]
.PP
.SS \[u25C6]\ PROGRAM_NAME
const char* PROGRAM_NAME = \[lq]YAIDS\[rq]
.PP
.SS \[u25C6]\ PROGRAM_SUBLINE
const char* PROGRAM_SUBLINE
.PP
\f[B]Initial value:\f[R]
.PP
=
.PP
\[lq]Yara as an Intrusion Detection System / Yet Another Intrusion
Detection System\[rq]
.PP
.SS \[u25C6]\ PROGRAM_VERSION
const char* PROGRAM_VERSION = PACKAGE_VERSION
.PP
   *   *   *   *   *
.PP
Source Code Documentation Generated By \f[C]doxygen\f[R] \ 
.SH yaidsconf
.PP
YAIDS
.PP
Functions
.PP
yaidsconf.c File Reference
.PP
\f[C]#include <config.h>\f[R]
.PD 0
.P
.PD
\f[C]#include <ctype.h>\f[R]
.PD 0
.P
.PD
\f[C]#include <stdio.h>\f[R]
.PD 0
.P
.PD
\f[C]#include <stdlib.h>\f[R]
.PD 0
.P
.PD
\f[C]#include <unistd.h>\f[R]
.PD 0
.P
.PD
\f[C]#include <stdbool.h>\f[R]
.PD 0
.P
.PD
\f[C]#include <yaids.h>\f[R]
.PD 0
.P
.PD
\f[C]#include <yaidstypes.h>\f[R]
.PD 0
.P
.PD
\f[C]#include <yaidsconf.h>\f[R]
.PD 0
.P
.PD
\f[C]#include <yaidsio.h>\f[R]
.PD 0
.P
.PD
\f[C]#include <yaidspcap.h>\f[R]
.PD 0
.P
.PD
\f[C]#include <yaidsyara.h>\f[R]
.PD 0
.P
.PD
\f[C]#include <yaidsthread.h>\f[R]
.PD 0
.P
.PD
\f[C]#include <sys/sysinfo.h>\f[R]
.PP
Include dependency graph for yaidsconf.c:
.PP

.SS  Functions
.PP
yaidsConfig\ 
.PP
yaidsconf_init (void)
.PP
\ 
.PP
int\ 
.PP
yaidsconf_get_default_thread_count (void)
.PP
\ 
.PP
void\ 
.PP
yaidsconf_config_init (yaidsConfig_ptr config, char *exeName, int
options)
.PP
\ 
.SS Function Documentation
.PP
.SS \[u25C6]\ yaidsconf_config_init()
void yaidsconf_config_init
(
yaidsConfig_ptr\ 
config,
char *\ 
exeName,
int\ 
options\ 
)
.PP
.SS \[u25C6]\ yaidsconf_get_default_thread_count()
int yaidsconf_get_default_thread_count
(
void\ 
)
.PP
.SS \[u25C6]\ yaidsconf_init()
yaidsConfig yaidsconf_init
(
void\ 
)
.PP
   *   *   *   *   *
.PP
Source Code Documentation Generated By \f[C]doxygen\f[R] \ 
.SH yaidsio
.PP
YAIDS
.PP
Functions
.PP
yaidsio.c File Reference
.PP
\f[C]#include <config.h>\f[R]
.PD 0
.P
.PD
\f[C]#include <ctype.h>\f[R]
.PD 0
.P
.PD
\f[C]#include <stdio.h>\f[R]
.PD 0
.P
.PD
\f[C]#include <stdlib.h>\f[R]
.PD 0
.P
.PD
\f[C]#include <unistd.h>\f[R]
.PD 0
.P
.PD
\f[C]#include <stdbool.h>\f[R]
.PD 0
.P
.PD
\f[C]#include <time.h>\f[R]
.PD 0
.P
.PD
\f[C]#include <yaids.h>\f[R]
.PD 0
.P
.PD
\f[C]#include <yaidstypes.h>\f[R]
.PD 0
.P
.PD
\f[C]#include <yaidsconf.h>\f[R]
.PD 0
.P
.PD
\f[C]#include <yaidsio.h>\f[R]
.PD 0
.P
.PD
\f[C]#include <yaidspcap.h>\f[R]
.PD 0
.P
.PD
\f[C]#include <yaidsyara.h>\f[R]
.PD 0
.P
.PD
\f[C]#include <yaidsthread.h>\f[R]
.PD 0
.P
.PD
\f[C]#include <stdarg.h>\f[R]
.PP
Include dependency graph for yaidsio.c:
.PP

.SS  Functions
.PP
void\ 
.PP
yaidsio_print_debug_line (const char *format,\&...)
.PP
\ 
.PP
void\ 
.PP
yaidsio_print_error_line (const char *format,\&...)
.PP
\ 
.PP
void\ 
.PP
yaidsio_print_std_line (const char *format,\&...)
.PP
\ 
.PP
void\ 
.PP
yaidsio_print_std_string (const char *format,\&...)
.PP
\ 
.PP
void\ 
.PP
yaidsio_print_horizontal_line (int chars)
.PP
\ 
.PP
void\ 
.PP
yaidsio_print_header (void)
.PP
\ 
.PP
void\ 
.PP
yaidsio_print_arg_line (char *opt, char *type, char *desc)
.PP
\ 
.PP
void\ 
.PP
yaidsio_help (char *exe)
.PP
\ 
.PP
void\ 
.PP
yaidsio_version (void)
.PP
\ 
.PP
yaidsConfig\ 
.PP
yaidsio_getopts (int argc, char **argv)
.PP
\ 
.PP
void\ 
.PP
yaidsio_print_config_debug (yaidsConfig_ptr config)
.PP
\ 
.PP
void\ 
.PP
yaidsio_exit_error (int errorCode)
.PP
\ 
.PP
void\ 
.PP
yaidsio_print_started (void)
.PP
\ 
.PP
void\ 
.PP
yaidsio_print_exiting (void)
.PP
\ 
.PP
void\ 
.PP
yaidsio_print_alert (char *alert)
.PP
\ 
.PP
void\ 
.PP
yaidsio_write_alert (FILE *alertFileHandle, char *alert)
.PP
\ 
.PP
void\ 
.PP
yaidsio_write_pcap (FILE *pcapFileHandle, yaidsPcapPacket_ptr packet)
.PP
\ 
.SS Function Documentation
.PP
.SS \[u25C6]\ yaidsio_exit_error()
void yaidsio_exit_error
(
int\ 
errorCode
)
.PP
.SS \[u25C6]\ yaidsio_getopts()
yaidsConfig yaidsio_getopts
(
int\ 
argc,
char **\ 
argv\ 
)
.PP
.SS \[u25C6]\ yaidsio_help()
void yaidsio_help
(
char *\ 
exe
)
.PP
.SS \[u25C6]\ yaidsio_print_alert()
void yaidsio_print_alert
(
char *\ 
alert
)
.PP
.SS \[u25C6]\ yaidsio_print_arg_line()
void yaidsio_print_arg_line
(
char *\ 
opt,
char *\ 
type,
char *\ 
desc\ 
)
.PP
.SS \[u25C6]\ yaidsio_print_config_debug()
void yaidsio_print_config_debug
(
yaidsConfig_ptr\ 
config
)
.PP
.SS \[u25C6]\ yaidsio_print_debug_line()
void yaidsio_print_debug_line
(
const char *\ 
format,
\ 
\&...\ 
)
.PP
.SS \[u25C6]\ yaidsio_print_error_line()
void yaidsio_print_error_line
(
const char *\ 
format,
\ 
\&...\ 
)
.PP
.SS \[u25C6]\ yaidsio_print_exiting()
void yaidsio_print_exiting
(
void\ 
)
.PP
.SS \[u25C6]\ yaidsio_print_header()
void yaidsio_print_header
(
void\ 
)
.PP
.SS \[u25C6]\ yaidsio_print_horizontal_line()
void yaidsio_print_horizontal_line
(
int\ 
chars
)
.PP
.SS \[u25C6]\ yaidsio_print_started()
void yaidsio_print_started
(
void\ 
)
.PP
.SS \[u25C6]\ yaidsio_print_std_line()
void yaidsio_print_std_line
(
const char *\ 
format,
\ 
\&...\ 
)
.PP
.SS \[u25C6]\ yaidsio_print_std_string()
void yaidsio_print_std_string
(
const char *\ 
format,
\ 
\&...\ 
)
.PP
.SS \[u25C6]\ yaidsio_version()
void yaidsio_version
(
void\ 
)
.PP
.SS \[u25C6]\ yaidsio_write_alert()
void yaidsio_write_alert
(
FILE *\ 
alertFileHandle,
char *\ 
alert\ 
)
.PP
.SS \[u25C6]\ yaidsio_write_pcap()
void yaidsio_write_pcap
(
FILE *\ 
pcapFileHandle,
yaidsPcapPacket_ptr\ 
packet\ 
)
.PP
   *   *   *   *   *
.PP
Source Code Documentation Generated By \f[C]doxygen\f[R] \ 
.SH yaidspcap
.PP
YAIDS
.PP
Functions
.PP
yaidspcap.c File Reference
.PP
\f[C]#include <config.h>\f[R]
.PD 0
.P
.PD
\f[C]#include <ctype.h>\f[R]
.PD 0
.P
.PD
\f[C]#include <stdio.h>\f[R]
.PD 0
.P
.PD
\f[C]#include <stdlib.h>\f[R]
.PD 0
.P
.PD
\f[C]#include <unistd.h>\f[R]
.PD 0
.P
.PD
\f[C]#include <stdbool.h>\f[R]
.PD 0
.P
.PD
\f[C]#include <malloc.h>\f[R]
.PD 0
.P
.PD
\f[C]#include <yaids.h>\f[R]
.PD 0
.P
.PD
\f[C]#include <yaidstypes.h>\f[R]
.PD 0
.P
.PD
\f[C]#include <yaidsconf.h>\f[R]
.PD 0
.P
.PD
\f[C]#include <yaidsio.h>\f[R]
.PD 0
.P
.PD
\f[C]#include <yaidspcap.h>\f[R]
.PD 0
.P
.PD
\f[C]#include <yaidsyara.h>\f[R]
.PD 0
.P
.PD
\f[C]#include <yaidsthread.h>\f[R]
.PD 0
.P
.PD
\f[C]#include <pcap.h>\f[R]
.PD 0
.P
.PD
\f[C]#include <sys/socket.h>\f[R]
.PD 0
.P
.PD
\f[C]#include <arpa/inet.h>\f[R]
.PD 0
.P
.PD
\f[C]#include <net/ethernet.h>\f[R]
.PD 0
.P
.PD
\f[C]#include <netinet/in.h>\f[R]
.PD 0
.P
.PD
\f[C]#include <netinet/ether.h>\f[R]
.PD 0
.P
.PD
\f[C]#include <netinet/if_ether.h>\f[R]
.PD 0
.P
.PD
\f[C]#include <netinet/ip.h>\f[R]
.PD 0
.P
.PD
\f[C]#include <netinet/tcp.h>\f[R]
.PD 0
.P
.PD
\f[C]#include <netinet/udp.h>\f[R]
.PD 0
.P
.PD
\f[C]#include <ethertypes.h>\f[R]
.PP
Include dependency graph for yaidspcap.c:
.PP

.SS  Functions
.PP
void\ 
.PP
yaidspcap_init (yaidsPcapHandle_ptr pcapHandle)
.PP
\ 
.PP
yaidsPcapPacket_ptr\ 
.PP
yaidspcap_new_packet (int size)
.PP
\ 
.PP
int\ 
.PP
yaidspcap_create_handle (yaidsConfig_ptr config, yaidsPcapHandle_ptr
pcapHandle)
.PP
\ 
.PP
void\ 
.PP
yaidspcap_read_packets (yaidsPcapHandle_ptr pcapHandle,
yaidsPcapCallbackArgs_ptr callbackArgs)
.PP
\ 
.PP
void\ 
.PP
yaidspcap_read_callback (u_char *args, const struct pcap_pkthdr
*packetHeader, const u_char *packetBody)
.PP
\ 
.PP
yaidsPcapPacketHeaderFrame_ptr\ 
.PP
yaidspcap_parse_pcap_headers_frame (etherHeader_ptr etherHeader)
.PP
\ 
.PP
yaidsPcapPacketHeaderNet_ptr\ 
.PP
yaidspcap_parse_pcap_headers_net (etherHeader_ptr etherHeader,
ipHeader_ptr ipHeader)
.PP
\ 
.PP
yaidsPcapPacketHeaderTransport_ptr\ 
.PP
yaidspcap_parse_pcap_headers_transport (yaidsPcapPacket_ptr packet,
ipHeader_ptr ipHeader)
.PP
\ 
.PP
char *\ 
.PP
yaidspcap_parse_pcap_headers_get_nettype (etherHeader_ptr etherHeader)
.PP
\ 
.PP
char *\ 
.PP
yaidspcap_parse_pcap_headers_get_transporttype (ipHeader_ptr ipHeader)
.PP
\ 
.PP
void\ 
.PP
yaidspcap_parse_pcap_headers_results (yaidsPcapPacketHeader_ptr
parsedPacketHeaders, yaidsPcapPacketHeaderFrame_ptr frameHeader,
yaidsPcapPacketHeaderNet_ptr netHeader,
yaidsPcapPacketHeaderTransport_ptr transportHeader)
.PP
\ 
.PP
void\ 
.PP
yaidspcap_parse_pcap_headers (yaidsPcapPacket_ptr packet,
yaidsPcapPacketHeader_ptr parsedPacketHeaders)
.PP
\ 
.PP
FILE *\ 
.PP
yaidspcap_open_output_pcap_file (yaidsPcapHandle_ptr pcapHandle,
yaidsConfig_ptr config)
.PP
\ 
.PP
void\ 
.PP
yaidspcap_write_packet (FILE *pcapFileHandle, yaidsPcapPacket_ptr
packet)
.PP
\ 
.PP
void\ 
.PP
yaidspcap_flush_output (FILE *pcapFileHandle)
.PP
\ 
.SS Function Documentation
.PP
.SS \[u25C6]\ yaidspcap_create_handle()
int yaidspcap_create_handle
(
yaidsConfig_ptr\ 
config,
yaidsPcapHandle_ptr\ 
pcapHandle\ 
)
.PP
.SS \[u25C6]\ yaidspcap_flush_output()
void yaidspcap_flush_output
(
FILE *\ 
pcapFileHandle
)
.PP
.SS \[u25C6]\ yaidspcap_init()
void yaidspcap_init
(
yaidsPcapHandle_ptr\ 
pcapHandle
)
.PP
.SS \[u25C6]\ yaidspcap_new_packet()
yaidsPcapPacket_ptr yaidspcap_new_packet
(
int\ 
size
)
.PP
.SS \[u25C6]\ yaidspcap_open_output_pcap_file()
FILE* yaidspcap_open_output_pcap_file
(
yaidsPcapHandle_ptr\ 
pcapHandle,
yaidsConfig_ptr\ 
config\ 
)
.PP
.SS \[u25C6]\ yaidspcap_parse_pcap_headers()
void yaidspcap_parse_pcap_headers
(
yaidsPcapPacket_ptr\ 
packet,
yaidsPcapPacketHeader_ptr\ 
parsedPacketHeaders\ 
)
.PP
.SS \[u25C6]\ yaidspcap_parse_pcap_headers_frame()
yaidsPcapPacketHeaderFrame_ptr yaidspcap_parse_pcap_headers_frame
(
etherHeader_ptr\ 
etherHeader
)
.PP
.SS \[u25C6]\ yaidspcap_parse_pcap_headers_get_nettype()
char* yaidspcap_parse_pcap_headers_get_nettype
(
etherHeader_ptr\ 
etherHeader
)
.PP
.SS \[u25C6]\ yaidspcap_parse_pcap_headers_get_transporttype()
char* yaidspcap_parse_pcap_headers_get_transporttype
(
ipHeader_ptr\ 
ipHeader
)
.PP
.SS \[u25C6]\ yaidspcap_parse_pcap_headers_net()
yaidsPcapPacketHeaderNet_ptr yaidspcap_parse_pcap_headers_net
(
etherHeader_ptr\ 
etherHeader,
ipHeader_ptr\ 
ipHeader\ 
)
.PP
.SS \[u25C6]\ yaidspcap_parse_pcap_headers_results()
void yaidspcap_parse_pcap_headers_results
(
yaidsPcapPacketHeader_ptr\ 
parsedPacketHeaders,
yaidsPcapPacketHeaderFrame_ptr\ 
frameHeader,
yaidsPcapPacketHeaderNet_ptr\ 
netHeader,
yaidsPcapPacketHeaderTransport_ptr\ 
transportHeader\ 
)
.PP
.SS \[u25C6]\ yaidspcap_parse_pcap_headers_transport()
yaidsPcapPacketHeaderTransport_ptr
yaidspcap_parse_pcap_headers_transport
(
yaidsPcapPacket_ptr\ 
packet,
ipHeader_ptr\ 
ipHeader\ 
)
.PP
.SS \[u25C6]\ yaidspcap_read_callback()
void yaidspcap_read_callback
(
u_char *\ 
args,
const struct pcap_pkthdr *\ 
packetHeader,
const u_char *\ 
packetBody\ 
)
.PP
.SS \[u25C6]\ yaidspcap_read_packets()
void yaidspcap_read_packets
(
yaidsPcapHandle_ptr\ 
pcapHandle,
yaidsPcapCallbackArgs_ptr\ 
callbackArgs\ 
)
.PP
.SS \[u25C6]\ yaidspcap_write_packet()
void yaidspcap_write_packet
(
FILE *\ 
pcapFileHandle,
yaidsPcapPacket_ptr\ 
packet\ 
)
.PP
   *   *   *   *   *
.PP
Source Code Documentation Generated By \f[C]doxygen\f[R] \ 
.SH yaidsthread
.PP
YAIDS
.PP
Functions
.PP
yaidsthread.c File Reference
.PP
\f[C]#include <config.h>\f[R]
.PD 0
.P
.PD
\f[C]#include <ctype.h>\f[R]
.PD 0
.P
.PD
\f[C]#include <stdio.h>\f[R]
.PD 0
.P
.PD
\f[C]#include <stdlib.h>\f[R]
.PD 0
.P
.PD
\f[C]#include <unistd.h>\f[R]
.PD 0
.P
.PD
\f[C]#include <stdbool.h>\f[R]
.PD 0
.P
.PD
\f[C]#include <malloc.h>\f[R]
.PD 0
.P
.PD
\f[C]#include <yaids.h>\f[R]
.PD 0
.P
.PD
\f[C]#include <yaidstypes.h>\f[R]
.PD 0
.P
.PD
\f[C]#include <yaidsconf.h>\f[R]
.PD 0
.P
.PD
\f[C]#include <yaidsio.h>\f[R]
.PD 0
.P
.PD
\f[C]#include <yaidspcap.h>\f[R]
.PD 0
.P
.PD
\f[C]#include <yaidsyara.h>\f[R]
.PD 0
.P
.PD
\f[C]#include <yaidsthread.h>\f[R]
.PD 0
.P
.PD
\f[C]#include <pthread.h>\f[R]
.PD 0
.P
.PD
\f[C]#include <pcap.h>\f[R]
.PD 0
.P
.PD
\f[C]#include <signal.h>\f[R]
.PD 0
.P
.PD
\f[C]#include <sys/prctl.h>\f[R]
.PD 0
.P
.PD
\f[C]#include <sys/types.h>\f[R]
.PD 0
.P
.PD
\f[C]#include <sys/stat.h>\f[R]
.PD 0
.P
.PD
\f[C]#include <fcntl.h>\f[R]
.PP
Include dependency graph for yaidsthread.c:
.PP

.SS  Functions
.PP
yaidsPacketCounts_ptr\ 
.PP
yaidsthread_new_packet_counts (void)
.PP
\ 
.PP
yaidsThreadStatuses_ptr\ 
.PP
yaidsthread_new_thread_statuses (void)
.PP
\ 
.PP
yaidsInputDataQueue_ptr\ 
.PP
yaidsthread_new_input_queue (void)
.PP
\ 
.PP
yaidsInputDataNode_ptr\ 
.PP
yaidsthread_new_input_data (yaidsPcapPacket_ptr packet)
.PP
\ 
.PP
yaidsInputThreadArgs_ptr\ 
.PP
yaidsthread_new_input_thread_args (yaidsInputDataQueue_ptr dataQueue,
yaidsPcapHandle_ptr pcapHandle, yaidsConfig_ptr config,
yaidsPacketCounts_ptr packetCounts, yaidsThreadStatuses_ptr
threadStatuses)
.PP
\ 
.PP
yaidsTimelimitThreadArgs_ptr\ 
.PP
yaidsthread_new_timelimit_thread_args (bool *yaidsRunning,
yaidsConfig_ptr config)
.PP
\ 
.PP
yaidsOutputDataQueue_ptr\ 
.PP
yaidsthread_new_output_queue (void)
.PP
\ 
.PP
yaidsOutputDataNode_ptr\ 
.PP
yaidsthread_new_output_data (yaidsPcapPacket_ptr packet, char *alert)
.PP
\ 
.PP
yaidsOutputThreadArgs_ptr\ 
.PP
yaidsthread_new_output_thread_args (yaidsOutputDataQueue_ptr dataQueue,
yaidsPcapHandle_ptr pcapHandle, yaidsConfig_ptr config,
yaidsPacketCounts_ptr packetCounts, yaidsThreadStatuses_ptr
threadStatuses)
.PP
\ 
.PP
yaidsYaraThreadArgs_ptr\ 
.PP
yaidsthread_new_yara_thread_args (yaidsInputDataQueue_ptr
inputDataQueue, yaidsOutputDataQueue_ptr outputDataQueue,
yaidsYaraScanner_ptr yaraScanner, yaidsConfig_ptr config,
yaidsPacketCounts_ptr packetCounts, yaidsThreadStatuses_ptr
threadStatuses)
.PP
\ 
.PP
void\ 
.PP
yaidsthread_update_pcap_packet_count (yaidsPacketCounts_ptr
packetCounts)
.PP
\ 
.PP
void\ 
.PP
yaidsthread_update_yara_packet_count (yaidsPacketCounts_ptr
packetCounts)
.PP
\ 
.PP
void\ 
.PP
yaidsthread_update_alert_packet_count (yaidsPacketCounts_ptr
packetCounts)
.PP
\ 
.PP
void\ 
.PP
yaidsthread_update_output_packet_count (yaidsPacketCounts_ptr
packetCounts)
.PP
\ 
.PP
void\ 
.PP
yaidsthread_set_pcap_finished (yaidsThreadStatuses_ptr threadStatuses,
yaidsConfig_ptr config)
.PP
\ 
.PP
void\ 
.PP
yaidsthread_set_yara_finished (yaidsThreadStatuses_ptr threadStatuses,
yaidsConfig_ptr config)
.PP
\ 
.PP
void\ 
.PP
yaidsthread_set_output_finished (yaidsThreadStatuses_ptr threadStatuses,
yaidsConfig_ptr config)
.PP
\ 
.PP
void\ 
.PP
yaidsthread_add_input_data (yaidsInputDataQueue_ptr dataQueue,
yaidsPcapPacket_ptr packet)
.PP
\ 
.PP
yaidsInputDataNode\ 
.PP
yaidsthread_get_input_data (yaidsInputDataQueue_ptr dataQueue)
.PP
\ 
.PP
void\ 
.PP
yaidsthread_add_output_data (yaidsOutputDataQueue_ptr dataQueue,
yaidsPcapPacket_ptr packet, char *alert)
.PP
\ 
.PP
yaidsOutputDataNode\ 
.PP
yaidsthread_get_output_data (yaidsOutputDataQueue_ptr dataQueue)
.PP
\ 
.PP
yaidsThreadReturn\ 
.PP
yaidsthread_create_pcap_thread (yaidsInputThreadArgs_ptr threadArgs)
.PP
\ 
.PP
yaidsThreadReturn\ 
.PP
yaidsthread_create_yara_thread (yaidsYaraThreadArgs_ptr threadArgs)
.PP
\ 
.PP
yaidsThreadReturn\ 
.PP
yaidsthread_create_output_thread (yaidsOutputThreadArgs_ptr threadArgs)
.PP
\ 
.PP
yaidsThreadReturn\ 
.PP
yaidsthread_create_timelimit_thread (yaidsTimelimitThreadArgs_ptr
threadArgs)
.PP
\ 
.PP
void *\ 
.PP
yaidsthread_pcap_thread (void *args)
.PP
\ 
.PP
void *\ 
.PP
yaidsthread_yara_thread (void *args)
.PP
\ 
.PP
void *\ 
.PP
yaidsthread_output_thread (void *args)
.PP
\ 
.PP
void *\ 
.PP
yaidsthread_timelimit_thread (void *args)
.PP
\ 
.PP
yaidsThreadList_ptr\ 
.PP
yaidsthread_new_threadlist (yaidsConfig_ptr config)
.PP
\ 
.PP
yaidsThreadInfo_ptr\ 
.PP
yaidsthread_new_threadinfo (void)
.PP
\ 
.PP
int\ 
.PP
yaidsthread_start_input_threads (yaidsConfig_ptr config,
yaidsThreadList_ptr threadList, yaidsThreadStatuses_ptr threadStatuses,
yaidsPcapHandle_ptr pcapHandle, yaidsInputDataQueue_ptr yaidsInputQueue,
yaidsPacketCounts_ptr packetCounts)
.PP
\ 
.PP
int\ 
.PP
yaidsthread_start_yara_threads (yaidsConfig_ptr config,
yaidsThreadList_ptr threadList, yaidsThreadStatuses_ptr threadStatuses,
yaidsInputDataQueue_ptr yaidsInputQueue, yaidsOutputDataQueue_ptr
yaidsOutputQueue, yaidsYaraScanner_ptr yaraScanners,
yaidsPacketCounts_ptr packetCounts)
.PP
\ 
.PP
int\ 
.PP
yaidsthread_start_output_threads (yaidsConfig_ptr config,
yaidsThreadList_ptr threadList, yaidsThreadStatuses_ptr threadStatuses,
yaidsPcapHandle_ptr pcapHandle, yaidsOutputDataQueue_ptr
yaidsOutputQueue, yaidsPacketCounts_ptr packetCounts, int
scannerThreadCount)
.PP
\ 
.PP
int\ 
.PP
yaidsthread_start_timelimit_threads (yaidsConfig_ptr config,
yaidsThreadList_ptr threadList, bool *yaidsRunning, int
scannerThreadCount)
.PP
\ 
.PP
int\ 
.PP
yaidsthread_run_threads (bool *yaidsRunning, yaidsConfig config,
yaidsThreadList_ptr threadList, yaidsInputDataQueue_ptr yaidsInputQueue,
yaidsOutputDataQueue_ptr yaidsOutputQueue, yaidsPcapHandle_ptr
pcapHandle, yaidsYaraScanner_ptr yaraScanners)
.PP
\ 
.SS Function Documentation
.PP
.SS \[u25C6]\ yaidsthread_add_input_data()
void yaidsthread_add_input_data
(
yaidsInputDataQueue_ptr\ 
dataQueue,
yaidsPcapPacket_ptr\ 
packet\ 
)
.PP
.SS \[u25C6]\ yaidsthread_add_output_data()
void yaidsthread_add_output_data
(
yaidsOutputDataQueue_ptr\ 
dataQueue,
yaidsPcapPacket_ptr\ 
packet,
char *\ 
alert\ 
)
.PP
.SS \[u25C6]\ yaidsthread_create_output_thread()
yaidsThreadReturn yaidsthread_create_output_thread
(
yaidsOutputThreadArgs_ptr\ 
threadArgs
)
.PP
.SS \[u25C6]\ yaidsthread_create_pcap_thread()
yaidsThreadReturn yaidsthread_create_pcap_thread
(
yaidsInputThreadArgs_ptr\ 
threadArgs
)
.PP
.SS \[u25C6]\ yaidsthread_create_timelimit_thread()
yaidsThreadReturn yaidsthread_create_timelimit_thread
(
yaidsTimelimitThreadArgs_ptr\ 
threadArgs
)
.PP
.SS \[u25C6]\ yaidsthread_create_yara_thread()
yaidsThreadReturn yaidsthread_create_yara_thread
(
yaidsYaraThreadArgs_ptr\ 
threadArgs
)
.PP
.SS \[u25C6]\ yaidsthread_get_input_data()
yaidsInputDataNode yaidsthread_get_input_data
(
yaidsInputDataQueue_ptr\ 
dataQueue
)
.PP
.SS \[u25C6]\ yaidsthread_get_output_data()
yaidsOutputDataNode yaidsthread_get_output_data
(
yaidsOutputDataQueue_ptr\ 
dataQueue
)
.PP
.SS \[u25C6]\ yaidsthread_new_input_data()
yaidsInputDataNode_ptr yaidsthread_new_input_data
(
yaidsPcapPacket_ptr\ 
packet
)
.PP
.SS \[u25C6]\ yaidsthread_new_input_queue()
yaidsInputDataQueue_ptr yaidsthread_new_input_queue
(
void\ 
)
.PP
.SS \[u25C6]\ yaidsthread_new_input_thread_args()
yaidsInputThreadArgs_ptr yaidsthread_new_input_thread_args
(
yaidsInputDataQueue_ptr\ 
dataQueue,
yaidsPcapHandle_ptr\ 
pcapHandle,
yaidsConfig_ptr\ 
config,
yaidsPacketCounts_ptr\ 
packetCounts,
yaidsThreadStatuses_ptr\ 
threadStatuses\ 
)
.PP
.SS \[u25C6]\ yaidsthread_new_output_data()
yaidsOutputDataNode_ptr yaidsthread_new_output_data
(
yaidsPcapPacket_ptr\ 
packet,
char *\ 
alert\ 
)
.PP
.SS \[u25C6]\ yaidsthread_new_output_queue()
yaidsOutputDataQueue_ptr yaidsthread_new_output_queue
(
void\ 
)
.PP
.SS \[u25C6]\ yaidsthread_new_output_thread_args()
yaidsOutputThreadArgs_ptr yaidsthread_new_output_thread_args
(
yaidsOutputDataQueue_ptr\ 
dataQueue,
yaidsPcapHandle_ptr\ 
pcapHandle,
yaidsConfig_ptr\ 
config,
yaidsPacketCounts_ptr\ 
packetCounts,
yaidsThreadStatuses_ptr\ 
threadStatuses\ 
)
.PP
.SS \[u25C6]\ yaidsthread_new_packet_counts()
yaidsPacketCounts_ptr yaidsthread_new_packet_counts
(
void\ 
)
.PP
.SS \[u25C6]\ yaidsthread_new_thread_statuses()
yaidsThreadStatuses_ptr yaidsthread_new_thread_statuses
(
void\ 
)
.PP
.SS \[u25C6]\ yaidsthread_new_threadinfo()
yaidsThreadInfo_ptr yaidsthread_new_threadinfo
(
void\ 
)
.PP
.SS \[u25C6]\ yaidsthread_new_threadlist()
yaidsThreadList_ptr yaidsthread_new_threadlist
(
yaidsConfig_ptr\ 
config
)
.PP
.SS \[u25C6]\ yaidsthread_new_timelimit_thread_args()
yaidsTimelimitThreadArgs_ptr yaidsthread_new_timelimit_thread_args
(
bool *\ 
yaidsRunning,
yaidsConfig_ptr\ 
config\ 
)
.PP
.SS \[u25C6]\ yaidsthread_new_yara_thread_args()
yaidsYaraThreadArgs_ptr yaidsthread_new_yara_thread_args
(
yaidsInputDataQueue_ptr\ 
inputDataQueue,
yaidsOutputDataQueue_ptr\ 
outputDataQueue,
yaidsYaraScanner_ptr\ 
yaraScanner,
yaidsConfig_ptr\ 
config,
yaidsPacketCounts_ptr\ 
packetCounts,
yaidsThreadStatuses_ptr\ 
threadStatuses\ 
)
.PP
.SS \[u25C6]\ yaidsthread_output_thread()
void* yaidsthread_output_thread
(
void *\ 
args
)
.PP
.SS \[u25C6]\ yaidsthread_pcap_thread()
void* yaidsthread_pcap_thread
(
void *\ 
args
)
.PP
.SS \[u25C6]\ yaidsthread_run_threads()
int yaidsthread_run_threads
(
bool *\ 
yaidsRunning,
yaidsConfig\ 
config,
yaidsThreadList_ptr\ 
threadList,
yaidsInputDataQueue_ptr\ 
yaidsInputQueue,
yaidsOutputDataQueue_ptr\ 
yaidsOutputQueue,
yaidsPcapHandle_ptr\ 
pcapHandle,
yaidsYaraScanner_ptr\ 
yaraScanners\ 
)
.PP
.SS \[u25C6]\ yaidsthread_set_output_finished()
void yaidsthread_set_output_finished
(
yaidsThreadStatuses_ptr\ 
threadStatuses,
yaidsConfig_ptr\ 
config\ 
)
.PP
.SS \[u25C6]\ yaidsthread_set_pcap_finished()
void yaidsthread_set_pcap_finished
(
yaidsThreadStatuses_ptr\ 
threadStatuses,
yaidsConfig_ptr\ 
config\ 
)
.PP
.SS \[u25C6]\ yaidsthread_set_yara_finished()
void yaidsthread_set_yara_finished
(
yaidsThreadStatuses_ptr\ 
threadStatuses,
yaidsConfig_ptr\ 
config\ 
)
.PP
.SS \[u25C6]\ yaidsthread_start_input_threads()
int yaidsthread_start_input_threads
(
yaidsConfig_ptr\ 
config,
yaidsThreadList_ptr\ 
threadList,
yaidsThreadStatuses_ptr\ 
threadStatuses,
yaidsPcapHandle_ptr\ 
pcapHandle,
yaidsInputDataQueue_ptr\ 
yaidsInputQueue,
yaidsPacketCounts_ptr\ 
packetCounts\ 
)
.PP
.SS \[u25C6]\ yaidsthread_start_output_threads()
int yaidsthread_start_output_threads
(
yaidsConfig_ptr\ 
config,
yaidsThreadList_ptr\ 
threadList,
yaidsThreadStatuses_ptr\ 
threadStatuses,
yaidsPcapHandle_ptr\ 
pcapHandle,
yaidsOutputDataQueue_ptr\ 
yaidsOutputQueue,
yaidsPacketCounts_ptr\ 
packetCounts,
int\ 
scannerThreadCount\ 
)
.PP
.SS \[u25C6]\ yaidsthread_start_timelimit_threads()
int yaidsthread_start_timelimit_threads
(
yaidsConfig_ptr\ 
config,
yaidsThreadList_ptr\ 
threadList,
bool *\ 
yaidsRunning,
int\ 
scannerThreadCount\ 
)
.PP
.SS \[u25C6]\ yaidsthread_start_yara_threads()
int yaidsthread_start_yara_threads
(
yaidsConfig_ptr\ 
config,
yaidsThreadList_ptr\ 
threadList,
yaidsThreadStatuses_ptr\ 
threadStatuses,
yaidsInputDataQueue_ptr\ 
yaidsInputQueue,
yaidsOutputDataQueue_ptr\ 
yaidsOutputQueue,
yaidsYaraScanner_ptr\ 
yaraScanners,
yaidsPacketCounts_ptr\ 
packetCounts\ 
)
.PP
.SS \[u25C6]\ yaidsthread_timelimit_thread()
void* yaidsthread_timelimit_thread
(
void *\ 
args
)
.PP
.SS \[u25C6]\ yaidsthread_update_alert_packet_count()
void yaidsthread_update_alert_packet_count
(
yaidsPacketCounts_ptr\ 
packetCounts
)
.PP
.SS \[u25C6]\ yaidsthread_update_output_packet_count()
void yaidsthread_update_output_packet_count
(
yaidsPacketCounts_ptr\ 
packetCounts
)
.PP
.SS \[u25C6]\ yaidsthread_update_pcap_packet_count()
void yaidsthread_update_pcap_packet_count
(
yaidsPacketCounts_ptr\ 
packetCounts
)
.PP
.SS \[u25C6]\ yaidsthread_update_yara_packet_count()
void yaidsthread_update_yara_packet_count
(
yaidsPacketCounts_ptr\ 
packetCounts
)
.PP
.SS \[u25C6]\ yaidsthread_yara_thread()
void* yaidsthread_yara_thread
(
void *\ 
args
)
.PP
   *   *   *   *   *
.PP
Source Code Documentation Generated By \f[C]doxygen\f[R] \ 
.SH yaidsyara
.PP
YAIDS
.PP
Functions
.PP
yaidsyara.c File Reference
.PP
\f[C]#include <config.h>\f[R]
.PD 0
.P
.PD
\f[C]#include <ctype.h>\f[R]
.PD 0
.P
.PD
\f[C]#include <stdio.h>\f[R]
.PD 0
.P
.PD
\f[C]#include <stdlib.h>\f[R]
.PD 0
.P
.PD
\f[C]#include <unistd.h>\f[R]
.PD 0
.P
.PD
\f[C]#include <stdbool.h>\f[R]
.PD 0
.P
.PD
\f[C]#include <yaids.h>\f[R]
.PD 0
.P
.PD
\f[C]#include <yaidstypes.h>\f[R]
.PD 0
.P
.PD
\f[C]#include <yaidsconf.h>\f[R]
.PD 0
.P
.PD
\f[C]#include <yaidsio.h>\f[R]
.PD 0
.P
.PD
\f[C]#include <yaidspcap.h>\f[R]
.PD 0
.P
.PD
\f[C]#include <yaidsyara.h>\f[R]
.PD 0
.P
.PD
\f[C]#include <yaidsthread.h>\f[R]
.PD 0
.P
.PD
\f[C]#include <yara.h>\f[R]
.PD 0
.P
.PD
\f[C]#include <yara/types.h>\f[R]
.PP
Include dependency graph for yaidsyara.c:
.PP

.SS  Functions
.PP
int\ 
.PP
yaidsyara_yara_initialize (void)
.PP
\ 
.PP
int\ 
.PP
yaidsyara_yara_finalize (void)
.PP
\ 
.PP
void\ 
.PP
yaidsyara_init (yaidsYaraScanner_ptr yara)
.PP
\ 
.PP
int\ 
.PP
yaidsyara_create_scanner (yaidsConfig_ptr config, yaidsYaraScanner_ptr
yara)
.PP
\ 
.PP
int\ 
.PP
yaidsyara_create_scanners (yaidsConfig_ptr config, yaidsYaraScanner_ptr
yaraScanners)
.PP
\ 
.PP
void\ 
.PP
yaidsyara_scan_packet (yaidsYaraScanner_ptr yaraScanner,
yaidsPcapPacket_ptr packet, yaidsOutputDataQueue_ptr yaidsOutputQueue,
yaidsYaraCallbackArgs_ptr callbackArgs, yaidsConfig_ptr config)
.PP
\ 
.PP
int\ 
.PP
yaidsyara_scanner_callback (YR_SCAN_CONTEXT *scanContext, int status,
void *rule, void *args)
.PP
\ 
.PP
char *\ 
.PP
yaidsyara_scanner_callback_get_alert (yaidsYaraCallbackArgs_ptr
callbackArgs, YR_RULE *yaraRule, YR_SCAN_CONTEXT *scanContext)
.PP
\ 
.PP
void\ 
.PP
yaidsyara_scanner_callback_get_alert_line (yaidsYaraCallbackArgs_ptr
callbackArgs, yaidsPcapPacketHeader_ptr parsedPacketHeaders, char
*alertString, int alertStringMax, char *timeString, char *ruleName, char
*metaMatch, char *stringMatch)
.PP
\ 
.PP
char *\ 
.PP
yaidsyara_scanner_callback_get_match_meta (YR_SCAN_CONTEXT *scanContext,
YR_RULE *yaraRule)
.PP
\ 
.PP
char *\ 
.PP
yaidsyara_scanner_callback_get_match_string (YR_SCAN_CONTEXT
*scanContext, YR_RULE *yaraRule)
.PP
\ 
.SS Function Documentation
.PP
.SS \[u25C6]\ yaidsyara_create_scanner()
int yaidsyara_create_scanner
(
yaidsConfig_ptr\ 
config,
yaidsYaraScanner_ptr\ 
yara\ 
)
.PP
.SS \[u25C6]\ yaidsyara_create_scanners()
int yaidsyara_create_scanners
(
yaidsConfig_ptr\ 
config,
yaidsYaraScanner_ptr\ 
yaraScanners\ 
)
.PP
.SS \[u25C6]\ yaidsyara_init()
void yaidsyara_init
(
yaidsYaraScanner_ptr\ 
yara
)
.PP
.SS \[u25C6]\ yaidsyara_scan_packet()
void yaidsyara_scan_packet
(
yaidsYaraScanner_ptr\ 
yaraScanner,
yaidsPcapPacket_ptr\ 
packet,
yaidsOutputDataQueue_ptr\ 
yaidsOutputQueue,
yaidsYaraCallbackArgs_ptr\ 
callbackArgs,
yaidsConfig_ptr\ 
config\ 
)
.PP
.SS \[u25C6]\ yaidsyara_scanner_callback()
int yaidsyara_scanner_callback
(
YR_SCAN_CONTEXT *\ 
scanContext,
int\ 
status,
void *\ 
rule,
void *\ 
args\ 
)
.PP
.SS \[u25C6]\ yaidsyara_scanner_callback_get_alert()
char* yaidsyara_scanner_callback_get_alert
(
yaidsYaraCallbackArgs_ptr\ 
callbackArgs,
YR_RULE *\ 
yaraRule,
YR_SCAN_CONTEXT *\ 
scanContext\ 
)
.PP
.SS \[u25C6]\ yaidsyara_scanner_callback_get_alert_line()
void yaidsyara_scanner_callback_get_alert_line
(
yaidsYaraCallbackArgs_ptr\ 
callbackArgs,
yaidsPcapPacketHeader_ptr\ 
parsedPacketHeaders,
char *\ 
alertString,
int\ 
alertStringMax,
char *\ 
timeString,
char *\ 
ruleName,
char *\ 
metaMatch,
char *\ 
stringMatch\ 
)
.PP
.SS \[u25C6]\ yaidsyara_scanner_callback_get_match_meta()
char* yaidsyara_scanner_callback_get_match_meta
(
YR_SCAN_CONTEXT *\ 
scanContext,
YR_RULE *\ 
yaraRule\ 
)
.PP
.SS \[u25C6]\ yaidsyara_scanner_callback_get_match_string()
char* yaidsyara_scanner_callback_get_match_string
(
YR_SCAN_CONTEXT *\ 
scanContext,
YR_RULE *\ 
yaraRule\ 
)
.PP
.SS \[u25C6]\ yaidsyara_yara_finalize()
int yaidsyara_yara_finalize
(
void\ 
)
.PP
.SS \[u25C6]\ yaidsyara_yara_initialize()
int yaidsyara_yara_initialize
(
void\ 
)
.PP
   *   *   *   *   *
.PP
Source Code Documentation Generated By \f[C]doxygen\f[R] \
